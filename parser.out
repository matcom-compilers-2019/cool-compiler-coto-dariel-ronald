Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> class SEMICOLON program
Rule 2     program -> class SEMICOLON
Rule 3     class -> CLASS TYPE inheritence LBRACE features RBRACE
Rule 4     inheritence -> INHERITS TYPE
Rule 5     inheritence -> empty
Rule 6     features -> feature SEMICOLON features
Rule 7     features -> empty
Rule 8     feature -> method_declaration
Rule 9     feature -> attribute
Rule 10    attribute -> id_type
Rule 11    attribute -> id_type ASSIGN expression
Rule 12    id_type -> ID TDOTS TYPE
Rule 13    method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE block
Rule 14    block -> LBRACE expression_list RBRACE
Rule 15    formals -> id_type COMMA formals
Rule 16    formals -> id_type
Rule 17    formals -> empty
Rule 18    expression_list -> expression SEMICOLON expression_list
Rule 19    expression_list -> expression SEMICOLON
Rule 20    expression -> assign
Rule 21    expression -> upper_non
Rule 22    upper_non -> NOT upper_non
Rule 23    upper_non -> operator_non
Rule 24    operator_non -> k_arith LTHAN k_arith
Rule 25    operator_non -> k_arith LETHAN k_arith
Rule 26    operator_non -> k_arith EQUALS k_arith
Rule 27    operator_non -> k_arith
Rule 28    k_arith -> arith
Rule 29    k_arith -> e_arith
Rule 30    assign -> ID ASSIGN expression
Rule 31    arith -> arith PLUS term
Rule 32    arith -> arith MINUS term
Rule 33    arith -> term
Rule 34    term -> term TIMES factor
Rule 35    term -> term DIVIDE factor
Rule 36    term -> factor
Rule 37    factor -> MINUS factor
Rule 38    factor -> atom
Rule 39    atom -> LBRACKET expression RBRACKET
Rule 40    atom -> INTEGER
Rule 41    atom -> STRING
Rule 42    atom -> ID
Rule 43    atom -> TRUE
Rule 44    atom -> FALSE
Rule 45    atom -> ISVOID expression
Rule 46    atom -> block
Rule 47    atom -> conditional
Rule 48    atom -> loop
Rule 49    atom -> case
Rule 50    atom -> dispatch
Rule 51    atom -> NEW TYPE
Rule 52    atom -> BCOMPLEMENT expression
Rule 53    e_arith -> arith PLUS e_term
Rule 54    e_arith -> arith MINUS e_term
Rule 55    e_arith -> e_term
Rule 56    e_term -> e_term TIMES e_factor
Rule 57    e_term -> e_term DIVIDE e_factor
Rule 58    e_term -> e_factor
Rule 59    e_factor -> MINUS e_factor
Rule 60    e_factor -> let_expression
Rule 61    let_expression -> LET declaration_list IN expression
Rule 62    declaration_list -> declaration COMMA declaration_list
Rule 63    declaration_list -> declaration
Rule 64    declaration -> id_type ASSIGN expression
Rule 65    declaration -> id_type
Rule 66    conditional -> IF expression THEN expression ELSE expression FI
Rule 67    loop -> WHILE expression LOOP expression POOL
Rule 68    case -> CASE expression OF implications ESAC
Rule 69    implications -> implication COMMA implications
Rule 70    implications -> implication
Rule 71    implication -> id_type IMPLY expression
Rule 72    dispatch -> expression especific DOT dispatch_call
Rule 73    dispatch -> dispatch_call
Rule 74    especific -> DISP TYPE
Rule 75    especific -> empty
Rule 76    dispatch_call -> ID LBRACKET params_expression RBRACKET
Rule 77    params_expression -> expression
Rule 78    params_expression -> expression COMMA params_expression
Rule 79    params_expression -> empty
Rule 80    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 11 30 64
BCOMPLEMENT          : 52
CASE                 : 68
CLASS                : 3
COMMA                : 15 62 69 78
DISP                 : 74
DIVIDE               : 35 57
DOT                  : 72
ELSE                 : 66
EQUALS               : 26
ESAC                 : 68
FALSE                : 44
FI                   : 66
ID                   : 12 13 30 42 76
IF                   : 66
IMPLY                : 71
IN                   : 61
INHERITS             : 4
INTEGER              : 40
ISVOID               : 45
LBRACE               : 3 14
LBRACKET             : 13 39 76
LET                  : 61
LETHAN               : 25
LOOP                 : 67
LTHAN                : 24
MINUS                : 32 37 54 59
NEW                  : 51
NOT                  : 22
OF                   : 68
PLUS                 : 31 53
POOL                 : 67
RBRACE               : 3 14
RBRACKET             : 13 39 76
SEMICOLON            : 1 2 6 18 19
STRING               : 41
TDOTS                : 12 13
THEN                 : 66
TIMES                : 34 56
TRUE                 : 43
TYPE                 : 3 4 12 13 51 74
WHILE                : 67
error                : 

Nonterminals, with rules where they appear

arith                : 28 31 32 53 54
assign               : 20
atom                 : 38
attribute            : 9
block                : 13 46
case                 : 49
class                : 1 2
conditional          : 47
declaration          : 62 63
declaration_list     : 61 62
dispatch             : 50
dispatch_call        : 72 73
e_arith              : 29
e_factor             : 56 57 58 59
e_term               : 53 54 55 56 57
empty                : 5 7 17 75 79
especific            : 72
expression           : 11 18 19 30 39 45 52 61 64 66 66 66 67 67 68 71 72 77 78
expression_list      : 14 18
factor               : 34 35 36 37
feature              : 6
features             : 3 6
formals              : 13 15
id_type              : 10 11 15 16 64 65 71
implication          : 69 70
implications         : 68 69
inheritence          : 3
k_arith              : 24 24 25 25 26 26 27
let_expression       : 60
loop                 : 48
method_declaration   : 8
operator_non         : 23
params_expression    : 76 78
program              : 1 0
term                 : 31 32 33 34 35
upper_non            : 21 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class SEMICOLON program
    (2) program -> . class SEMICOLON
    (3) class -> . CLASS TYPE inheritence LBRACE features RBRACE

    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> class . SEMICOLON program
    (2) program -> class . SEMICOLON

    SEMICOLON       shift and go to state 4


state 3

    (3) class -> CLASS . TYPE inheritence LBRACE features RBRACE

    TYPE            shift and go to state 5


state 4

    (1) program -> class SEMICOLON . program
    (2) program -> class SEMICOLON .
    (1) program -> . class SEMICOLON program
    (2) program -> . class SEMICOLON
    (3) class -> . CLASS TYPE inheritence LBRACE features RBRACE

    $end            reduce using rule 2 (program -> class SEMICOLON .)
    CLASS           shift and go to state 3

    class                          shift and go to state 2
    program                        shift and go to state 6

state 5

    (3) class -> CLASS TYPE . inheritence LBRACE features RBRACE
    (4) inheritence -> . INHERITS TYPE
    (5) inheritence -> . empty
    (80) empty -> .

    INHERITS        shift and go to state 8
    LBRACE          reduce using rule 80 (empty -> .)

    inheritence                    shift and go to state 7
    empty                          shift and go to state 9

state 6

    (1) program -> class SEMICOLON program .

    $end            reduce using rule 1 (program -> class SEMICOLON program .)


state 7

    (3) class -> CLASS TYPE inheritence . LBRACE features RBRACE

    LBRACE          shift and go to state 10


state 8

    (4) inheritence -> INHERITS . TYPE

    TYPE            shift and go to state 11


state 9

    (5) inheritence -> empty .

    LBRACE          reduce using rule 5 (inheritence -> empty .)


state 10

    (3) class -> CLASS TYPE inheritence LBRACE . features RBRACE
    (6) features -> . feature SEMICOLON features
    (7) features -> . empty
    (8) feature -> . method_declaration
    (9) feature -> . attribute
    (80) empty -> .
    (13) method_declaration -> . ID LBRACKET formals RBRACKET TDOTS TYPE block
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    RBRACE          reduce using rule 80 (empty -> .)
    ID              shift and go to state 17

    features                       shift and go to state 12
    feature                        shift and go to state 13
    empty                          shift and go to state 14
    method_declaration             shift and go to state 15
    attribute                      shift and go to state 16
    id_type                        shift and go to state 18

state 11

    (4) inheritence -> INHERITS TYPE .

    LBRACE          reduce using rule 4 (inheritence -> INHERITS TYPE .)


state 12

    (3) class -> CLASS TYPE inheritence LBRACE features . RBRACE

    RBRACE          shift and go to state 19


state 13

    (6) features -> feature . SEMICOLON features

    SEMICOLON       shift and go to state 20


state 14

    (7) features -> empty .

    RBRACE          reduce using rule 7 (features -> empty .)


state 15

    (8) feature -> method_declaration .

    SEMICOLON       reduce using rule 8 (feature -> method_declaration .)


state 16

    (9) feature -> attribute .

    SEMICOLON       reduce using rule 9 (feature -> attribute .)


state 17

    (13) method_declaration -> ID . LBRACKET formals RBRACKET TDOTS TYPE block
    (12) id_type -> ID . TDOTS TYPE

    LBRACKET        shift and go to state 21
    TDOTS           shift and go to state 22


state 18

    (10) attribute -> id_type .
    (11) attribute -> id_type . ASSIGN expression

    SEMICOLON       reduce using rule 10 (attribute -> id_type .)
    ASSIGN          shift and go to state 23


state 19

    (3) class -> CLASS TYPE inheritence LBRACE features RBRACE .

    SEMICOLON       reduce using rule 3 (class -> CLASS TYPE inheritence LBRACE features RBRACE .)


state 20

    (6) features -> feature SEMICOLON . features
    (6) features -> . feature SEMICOLON features
    (7) features -> . empty
    (8) feature -> . method_declaration
    (9) feature -> . attribute
    (80) empty -> .
    (13) method_declaration -> . ID LBRACKET formals RBRACKET TDOTS TYPE block
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    RBRACE          reduce using rule 80 (empty -> .)
    ID              shift and go to state 17

    feature                        shift and go to state 13
    features                       shift and go to state 24
    empty                          shift and go to state 14
    method_declaration             shift and go to state 15
    attribute                      shift and go to state 16
    id_type                        shift and go to state 18

state 21

    (13) method_declaration -> ID LBRACKET . formals RBRACKET TDOTS TYPE block
    (15) formals -> . id_type COMMA formals
    (16) formals -> . id_type
    (17) formals -> . empty
    (12) id_type -> . ID TDOTS TYPE
    (80) empty -> .

    ID              shift and go to state 25
    RBRACKET        reduce using rule 80 (empty -> .)

    formals                        shift and go to state 26
    id_type                        shift and go to state 27
    empty                          shift and go to state 28

state 22

    (12) id_type -> ID TDOTS . TYPE

    TYPE            shift and go to state 29


state 23

    (11) attribute -> id_type ASSIGN . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 30
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 24

    (6) features -> feature SEMICOLON features .

    RBRACE          reduce using rule 6 (features -> feature SEMICOLON features .)


state 25

    (12) id_type -> ID . TDOTS TYPE

    TDOTS           shift and go to state 22


state 26

    (13) method_declaration -> ID LBRACKET formals . RBRACKET TDOTS TYPE block

    RBRACKET        shift and go to state 65


state 27

    (15) formals -> id_type . COMMA formals
    (16) formals -> id_type .

    COMMA           shift and go to state 66
    RBRACKET        reduce using rule 16 (formals -> id_type .)


state 28

    (17) formals -> empty .

    RBRACKET        reduce using rule 17 (formals -> empty .)


state 29

    (12) id_type -> ID TDOTS TYPE .

    ASSIGN          reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    SEMICOLON       reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    COMMA           reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    RBRACKET        reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    IN              reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    IMPLY           reduce using rule 12 (id_type -> ID TDOTS TYPE .)


state 30

    (11) attribute -> id_type ASSIGN expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    SEMICOLON       reduce using rule 11 (attribute -> id_type ASSIGN expression .)
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 31

    (20) expression -> assign .

    DISP            reduce using rule 20 (expression -> assign .)
    DOT             reduce using rule 20 (expression -> assign .)
    SEMICOLON       reduce using rule 20 (expression -> assign .)
    RBRACKET        reduce using rule 20 (expression -> assign .)
    TIMES           reduce using rule 20 (expression -> assign .)
    DIVIDE          reduce using rule 20 (expression -> assign .)
    PLUS            reduce using rule 20 (expression -> assign .)
    MINUS           reduce using rule 20 (expression -> assign .)
    LTHAN           reduce using rule 20 (expression -> assign .)
    LETHAN          reduce using rule 20 (expression -> assign .)
    EQUALS          reduce using rule 20 (expression -> assign .)
    THEN            reduce using rule 20 (expression -> assign .)
    LOOP            reduce using rule 20 (expression -> assign .)
    OF              reduce using rule 20 (expression -> assign .)
    COMMA           reduce using rule 20 (expression -> assign .)
    IN              reduce using rule 20 (expression -> assign .)
    ELSE            reduce using rule 20 (expression -> assign .)
    POOL            reduce using rule 20 (expression -> assign .)
    FI              reduce using rule 20 (expression -> assign .)
    ESAC            reduce using rule 20 (expression -> assign .)


state 32

    (21) expression -> upper_non .

    DISP            reduce using rule 21 (expression -> upper_non .)
    DOT             reduce using rule 21 (expression -> upper_non .)
    SEMICOLON       reduce using rule 21 (expression -> upper_non .)
    RBRACKET        reduce using rule 21 (expression -> upper_non .)
    TIMES           reduce using rule 21 (expression -> upper_non .)
    DIVIDE          reduce using rule 21 (expression -> upper_non .)
    PLUS            reduce using rule 21 (expression -> upper_non .)
    MINUS           reduce using rule 21 (expression -> upper_non .)
    LTHAN           reduce using rule 21 (expression -> upper_non .)
    LETHAN          reduce using rule 21 (expression -> upper_non .)
    EQUALS          reduce using rule 21 (expression -> upper_non .)
    THEN            reduce using rule 21 (expression -> upper_non .)
    LOOP            reduce using rule 21 (expression -> upper_non .)
    OF              reduce using rule 21 (expression -> upper_non .)
    COMMA           reduce using rule 21 (expression -> upper_non .)
    IN              reduce using rule 21 (expression -> upper_non .)
    ELSE            reduce using rule 21 (expression -> upper_non .)
    POOL            reduce using rule 21 (expression -> upper_non .)
    FI              reduce using rule 21 (expression -> upper_non .)
    ESAC            reduce using rule 21 (expression -> upper_non .)


state 33

    (30) assign -> ID . ASSIGN expression
    (42) atom -> ID .
    (76) dispatch_call -> ID . LBRACKET params_expression RBRACKET

    ASSIGN          shift and go to state 70
    TIMES           reduce using rule 42 (atom -> ID .)
    DIVIDE          reduce using rule 42 (atom -> ID .)
    PLUS            reduce using rule 42 (atom -> ID .)
    MINUS           reduce using rule 42 (atom -> ID .)
    LTHAN           reduce using rule 42 (atom -> ID .)
    LETHAN          reduce using rule 42 (atom -> ID .)
    EQUALS          reduce using rule 42 (atom -> ID .)
    DISP            reduce using rule 42 (atom -> ID .)
    DOT             reduce using rule 42 (atom -> ID .)
    SEMICOLON       reduce using rule 42 (atom -> ID .)
    RBRACKET        reduce using rule 42 (atom -> ID .)
    THEN            reduce using rule 42 (atom -> ID .)
    LOOP            reduce using rule 42 (atom -> ID .)
    OF              reduce using rule 42 (atom -> ID .)
    COMMA           reduce using rule 42 (atom -> ID .)
    IN              reduce using rule 42 (atom -> ID .)
    ELSE            reduce using rule 42 (atom -> ID .)
    POOL            reduce using rule 42 (atom -> ID .)
    FI              reduce using rule 42 (atom -> ID .)
    ESAC            reduce using rule 42 (atom -> ID .)
    LBRACKET        shift and go to state 71


state 34

    (22) upper_non -> NOT . upper_non
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression

    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    upper_non                      shift and go to state 72
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31

state 35

    (23) upper_non -> operator_non .

    DISP            reduce using rule 23 (upper_non -> operator_non .)
    DOT             reduce using rule 23 (upper_non -> operator_non .)
    SEMICOLON       reduce using rule 23 (upper_non -> operator_non .)
    RBRACKET        reduce using rule 23 (upper_non -> operator_non .)
    TIMES           reduce using rule 23 (upper_non -> operator_non .)
    DIVIDE          reduce using rule 23 (upper_non -> operator_non .)
    PLUS            reduce using rule 23 (upper_non -> operator_non .)
    MINUS           reduce using rule 23 (upper_non -> operator_non .)
    LTHAN           reduce using rule 23 (upper_non -> operator_non .)
    LETHAN          reduce using rule 23 (upper_non -> operator_non .)
    EQUALS          reduce using rule 23 (upper_non -> operator_non .)
    THEN            reduce using rule 23 (upper_non -> operator_non .)
    LOOP            reduce using rule 23 (upper_non -> operator_non .)
    OF              reduce using rule 23 (upper_non -> operator_non .)
    COMMA           reduce using rule 23 (upper_non -> operator_non .)
    IN              reduce using rule 23 (upper_non -> operator_non .)
    ELSE            reduce using rule 23 (upper_non -> operator_non .)
    POOL            reduce using rule 23 (upper_non -> operator_non .)
    FI              reduce using rule 23 (upper_non -> operator_non .)
    ESAC            reduce using rule 23 (upper_non -> operator_non .)


state 36

    (24) operator_non -> k_arith . LTHAN k_arith
    (25) operator_non -> k_arith . LETHAN k_arith
    (26) operator_non -> k_arith . EQUALS k_arith
    (27) operator_non -> k_arith .

  ! shift/reduce conflict for LTHAN resolved as shift
  ! shift/reduce conflict for LETHAN resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
    LTHAN           shift and go to state 75
    LETHAN          shift and go to state 76
    EQUALS          shift and go to state 77
    DISP            reduce using rule 27 (operator_non -> k_arith .)
    DOT             reduce using rule 27 (operator_non -> k_arith .)
    SEMICOLON       reduce using rule 27 (operator_non -> k_arith .)
    RBRACKET        reduce using rule 27 (operator_non -> k_arith .)
    TIMES           reduce using rule 27 (operator_non -> k_arith .)
    DIVIDE          reduce using rule 27 (operator_non -> k_arith .)
    PLUS            reduce using rule 27 (operator_non -> k_arith .)
    MINUS           reduce using rule 27 (operator_non -> k_arith .)
    THEN            reduce using rule 27 (operator_non -> k_arith .)
    LOOP            reduce using rule 27 (operator_non -> k_arith .)
    OF              reduce using rule 27 (operator_non -> k_arith .)
    COMMA           reduce using rule 27 (operator_non -> k_arith .)
    IN              reduce using rule 27 (operator_non -> k_arith .)
    ELSE            reduce using rule 27 (operator_non -> k_arith .)
    POOL            reduce using rule 27 (operator_non -> k_arith .)
    FI              reduce using rule 27 (operator_non -> k_arith .)
    ESAC            reduce using rule 27 (operator_non -> k_arith .)

  ! LTHAN           [ reduce using rule 27 (operator_non -> k_arith .) ]
  ! LETHAN          [ reduce using rule 27 (operator_non -> k_arith .) ]
  ! EQUALS          [ reduce using rule 27 (operator_non -> k_arith .) ]


state 37

    (28) k_arith -> arith .
    (31) arith -> arith . PLUS term
    (32) arith -> arith . MINUS term
    (53) e_arith -> arith . PLUS e_term
    (54) e_arith -> arith . MINUS e_term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LTHAN           reduce using rule 28 (k_arith -> arith .)
    LETHAN          reduce using rule 28 (k_arith -> arith .)
    EQUALS          reduce using rule 28 (k_arith -> arith .)
    DISP            reduce using rule 28 (k_arith -> arith .)
    DOT             reduce using rule 28 (k_arith -> arith .)
    SEMICOLON       reduce using rule 28 (k_arith -> arith .)
    RBRACKET        reduce using rule 28 (k_arith -> arith .)
    TIMES           reduce using rule 28 (k_arith -> arith .)
    DIVIDE          reduce using rule 28 (k_arith -> arith .)
    THEN            reduce using rule 28 (k_arith -> arith .)
    LOOP            reduce using rule 28 (k_arith -> arith .)
    OF              reduce using rule 28 (k_arith -> arith .)
    COMMA           reduce using rule 28 (k_arith -> arith .)
    IN              reduce using rule 28 (k_arith -> arith .)
    ELSE            reduce using rule 28 (k_arith -> arith .)
    POOL            reduce using rule 28 (k_arith -> arith .)
    FI              reduce using rule 28 (k_arith -> arith .)
    ESAC            reduce using rule 28 (k_arith -> arith .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79

  ! PLUS            [ reduce using rule 28 (k_arith -> arith .) ]
  ! MINUS           [ reduce using rule 28 (k_arith -> arith .) ]


state 38

    (29) k_arith -> e_arith .

    LTHAN           reduce using rule 29 (k_arith -> e_arith .)
    LETHAN          reduce using rule 29 (k_arith -> e_arith .)
    EQUALS          reduce using rule 29 (k_arith -> e_arith .)
    DISP            reduce using rule 29 (k_arith -> e_arith .)
    DOT             reduce using rule 29 (k_arith -> e_arith .)
    SEMICOLON       reduce using rule 29 (k_arith -> e_arith .)
    RBRACKET        reduce using rule 29 (k_arith -> e_arith .)
    TIMES           reduce using rule 29 (k_arith -> e_arith .)
    DIVIDE          reduce using rule 29 (k_arith -> e_arith .)
    PLUS            reduce using rule 29 (k_arith -> e_arith .)
    MINUS           reduce using rule 29 (k_arith -> e_arith .)
    THEN            reduce using rule 29 (k_arith -> e_arith .)
    LOOP            reduce using rule 29 (k_arith -> e_arith .)
    OF              reduce using rule 29 (k_arith -> e_arith .)
    COMMA           reduce using rule 29 (k_arith -> e_arith .)
    IN              reduce using rule 29 (k_arith -> e_arith .)
    ELSE            reduce using rule 29 (k_arith -> e_arith .)
    POOL            reduce using rule 29 (k_arith -> e_arith .)
    FI              reduce using rule 29 (k_arith -> e_arith .)
    ESAC            reduce using rule 29 (k_arith -> e_arith .)


state 39

    (33) arith -> term .
    (34) term -> term . TIMES factor
    (35) term -> term . DIVIDE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 33 (arith -> term .)
    MINUS           reduce using rule 33 (arith -> term .)
    LTHAN           reduce using rule 33 (arith -> term .)
    LETHAN          reduce using rule 33 (arith -> term .)
    EQUALS          reduce using rule 33 (arith -> term .)
    DISP            reduce using rule 33 (arith -> term .)
    DOT             reduce using rule 33 (arith -> term .)
    SEMICOLON       reduce using rule 33 (arith -> term .)
    RBRACKET        reduce using rule 33 (arith -> term .)
    THEN            reduce using rule 33 (arith -> term .)
    LOOP            reduce using rule 33 (arith -> term .)
    OF              reduce using rule 33 (arith -> term .)
    COMMA           reduce using rule 33 (arith -> term .)
    IN              reduce using rule 33 (arith -> term .)
    ELSE            reduce using rule 33 (arith -> term .)
    POOL            reduce using rule 33 (arith -> term .)
    FI              reduce using rule 33 (arith -> term .)
    ESAC            reduce using rule 33 (arith -> term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 33 (arith -> term .) ]
  ! DIVIDE          [ reduce using rule 33 (arith -> term .) ]


state 40

    (37) factor -> MINUS . factor
    (59) e_factor -> MINUS . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    factor                         shift and go to state 82
    e_factor                       shift and go to state 83
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41

state 41

    (55) e_arith -> e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    LTHAN           reduce using rule 55 (e_arith -> e_term .)
    LETHAN          reduce using rule 55 (e_arith -> e_term .)
    EQUALS          reduce using rule 55 (e_arith -> e_term .)
    DISP            reduce using rule 55 (e_arith -> e_term .)
    DOT             reduce using rule 55 (e_arith -> e_term .)
    SEMICOLON       reduce using rule 55 (e_arith -> e_term .)
    RBRACKET        reduce using rule 55 (e_arith -> e_term .)
    PLUS            reduce using rule 55 (e_arith -> e_term .)
    MINUS           reduce using rule 55 (e_arith -> e_term .)
    THEN            reduce using rule 55 (e_arith -> e_term .)
    LOOP            reduce using rule 55 (e_arith -> e_term .)
    OF              reduce using rule 55 (e_arith -> e_term .)
    COMMA           reduce using rule 55 (e_arith -> e_term .)
    IN              reduce using rule 55 (e_arith -> e_term .)
    ELSE            reduce using rule 55 (e_arith -> e_term .)
    POOL            reduce using rule 55 (e_arith -> e_term .)
    FI              reduce using rule 55 (e_arith -> e_term .)
    ESAC            reduce using rule 55 (e_arith -> e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DIVIDE          [ reduce using rule 55 (e_arith -> e_term .) ]


state 42

    (36) term -> factor .

    TIMES           reduce using rule 36 (term -> factor .)
    DIVIDE          reduce using rule 36 (term -> factor .)
    PLUS            reduce using rule 36 (term -> factor .)
    MINUS           reduce using rule 36 (term -> factor .)
    LTHAN           reduce using rule 36 (term -> factor .)
    LETHAN          reduce using rule 36 (term -> factor .)
    EQUALS          reduce using rule 36 (term -> factor .)
    DISP            reduce using rule 36 (term -> factor .)
    DOT             reduce using rule 36 (term -> factor .)
    SEMICOLON       reduce using rule 36 (term -> factor .)
    RBRACKET        reduce using rule 36 (term -> factor .)
    THEN            reduce using rule 36 (term -> factor .)
    LOOP            reduce using rule 36 (term -> factor .)
    OF              reduce using rule 36 (term -> factor .)
    COMMA           reduce using rule 36 (term -> factor .)
    IN              reduce using rule 36 (term -> factor .)
    ELSE            reduce using rule 36 (term -> factor .)
    POOL            reduce using rule 36 (term -> factor .)
    FI              reduce using rule 36 (term -> factor .)
    ESAC            reduce using rule 36 (term -> factor .)


state 43

    (58) e_term -> e_factor .

    TIMES           reduce using rule 58 (e_term -> e_factor .)
    DIVIDE          reduce using rule 58 (e_term -> e_factor .)
    LTHAN           reduce using rule 58 (e_term -> e_factor .)
    LETHAN          reduce using rule 58 (e_term -> e_factor .)
    EQUALS          reduce using rule 58 (e_term -> e_factor .)
    DISP            reduce using rule 58 (e_term -> e_factor .)
    DOT             reduce using rule 58 (e_term -> e_factor .)
    SEMICOLON       reduce using rule 58 (e_term -> e_factor .)
    RBRACKET        reduce using rule 58 (e_term -> e_factor .)
    PLUS            reduce using rule 58 (e_term -> e_factor .)
    MINUS           reduce using rule 58 (e_term -> e_factor .)
    THEN            reduce using rule 58 (e_term -> e_factor .)
    LOOP            reduce using rule 58 (e_term -> e_factor .)
    OF              reduce using rule 58 (e_term -> e_factor .)
    COMMA           reduce using rule 58 (e_term -> e_factor .)
    IN              reduce using rule 58 (e_term -> e_factor .)
    ELSE            reduce using rule 58 (e_term -> e_factor .)
    POOL            reduce using rule 58 (e_term -> e_factor .)
    FI              reduce using rule 58 (e_term -> e_factor .)
    ESAC            reduce using rule 58 (e_term -> e_factor .)


state 44

    (38) factor -> atom .

    TIMES           reduce using rule 38 (factor -> atom .)
    DIVIDE          reduce using rule 38 (factor -> atom .)
    PLUS            reduce using rule 38 (factor -> atom .)
    MINUS           reduce using rule 38 (factor -> atom .)
    LTHAN           reduce using rule 38 (factor -> atom .)
    LETHAN          reduce using rule 38 (factor -> atom .)
    EQUALS          reduce using rule 38 (factor -> atom .)
    DISP            reduce using rule 38 (factor -> atom .)
    DOT             reduce using rule 38 (factor -> atom .)
    SEMICOLON       reduce using rule 38 (factor -> atom .)
    RBRACKET        reduce using rule 38 (factor -> atom .)
    THEN            reduce using rule 38 (factor -> atom .)
    LOOP            reduce using rule 38 (factor -> atom .)
    OF              reduce using rule 38 (factor -> atom .)
    COMMA           reduce using rule 38 (factor -> atom .)
    IN              reduce using rule 38 (factor -> atom .)
    ELSE            reduce using rule 38 (factor -> atom .)
    POOL            reduce using rule 38 (factor -> atom .)
    FI              reduce using rule 38 (factor -> atom .)
    ESAC            reduce using rule 38 (factor -> atom .)


state 45

    (60) e_factor -> let_expression .

    TIMES           reduce using rule 60 (e_factor -> let_expression .)
    DIVIDE          reduce using rule 60 (e_factor -> let_expression .)
    LTHAN           reduce using rule 60 (e_factor -> let_expression .)
    LETHAN          reduce using rule 60 (e_factor -> let_expression .)
    EQUALS          reduce using rule 60 (e_factor -> let_expression .)
    DISP            reduce using rule 60 (e_factor -> let_expression .)
    DOT             reduce using rule 60 (e_factor -> let_expression .)
    SEMICOLON       reduce using rule 60 (e_factor -> let_expression .)
    RBRACKET        reduce using rule 60 (e_factor -> let_expression .)
    PLUS            reduce using rule 60 (e_factor -> let_expression .)
    MINUS           reduce using rule 60 (e_factor -> let_expression .)
    THEN            reduce using rule 60 (e_factor -> let_expression .)
    LOOP            reduce using rule 60 (e_factor -> let_expression .)
    OF              reduce using rule 60 (e_factor -> let_expression .)
    COMMA           reduce using rule 60 (e_factor -> let_expression .)
    IN              reduce using rule 60 (e_factor -> let_expression .)
    ELSE            reduce using rule 60 (e_factor -> let_expression .)
    POOL            reduce using rule 60 (e_factor -> let_expression .)
    FI              reduce using rule 60 (e_factor -> let_expression .)
    ESAC            reduce using rule 60 (e_factor -> let_expression .)


state 46

    (39) atom -> LBRACKET . expression RBRACKET
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 86
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 47

    (40) atom -> INTEGER .

    TIMES           reduce using rule 40 (atom -> INTEGER .)
    DIVIDE          reduce using rule 40 (atom -> INTEGER .)
    PLUS            reduce using rule 40 (atom -> INTEGER .)
    MINUS           reduce using rule 40 (atom -> INTEGER .)
    LTHAN           reduce using rule 40 (atom -> INTEGER .)
    LETHAN          reduce using rule 40 (atom -> INTEGER .)
    EQUALS          reduce using rule 40 (atom -> INTEGER .)
    DISP            reduce using rule 40 (atom -> INTEGER .)
    DOT             reduce using rule 40 (atom -> INTEGER .)
    SEMICOLON       reduce using rule 40 (atom -> INTEGER .)
    RBRACKET        reduce using rule 40 (atom -> INTEGER .)
    THEN            reduce using rule 40 (atom -> INTEGER .)
    LOOP            reduce using rule 40 (atom -> INTEGER .)
    OF              reduce using rule 40 (atom -> INTEGER .)
    COMMA           reduce using rule 40 (atom -> INTEGER .)
    IN              reduce using rule 40 (atom -> INTEGER .)
    ELSE            reduce using rule 40 (atom -> INTEGER .)
    POOL            reduce using rule 40 (atom -> INTEGER .)
    FI              reduce using rule 40 (atom -> INTEGER .)
    ESAC            reduce using rule 40 (atom -> INTEGER .)


state 48

    (41) atom -> STRING .

    TIMES           reduce using rule 41 (atom -> STRING .)
    DIVIDE          reduce using rule 41 (atom -> STRING .)
    PLUS            reduce using rule 41 (atom -> STRING .)
    MINUS           reduce using rule 41 (atom -> STRING .)
    LTHAN           reduce using rule 41 (atom -> STRING .)
    LETHAN          reduce using rule 41 (atom -> STRING .)
    EQUALS          reduce using rule 41 (atom -> STRING .)
    DISP            reduce using rule 41 (atom -> STRING .)
    DOT             reduce using rule 41 (atom -> STRING .)
    SEMICOLON       reduce using rule 41 (atom -> STRING .)
    RBRACKET        reduce using rule 41 (atom -> STRING .)
    THEN            reduce using rule 41 (atom -> STRING .)
    LOOP            reduce using rule 41 (atom -> STRING .)
    OF              reduce using rule 41 (atom -> STRING .)
    COMMA           reduce using rule 41 (atom -> STRING .)
    IN              reduce using rule 41 (atom -> STRING .)
    ELSE            reduce using rule 41 (atom -> STRING .)
    POOL            reduce using rule 41 (atom -> STRING .)
    FI              reduce using rule 41 (atom -> STRING .)
    ESAC            reduce using rule 41 (atom -> STRING .)


state 49

    (43) atom -> TRUE .

    TIMES           reduce using rule 43 (atom -> TRUE .)
    DIVIDE          reduce using rule 43 (atom -> TRUE .)
    PLUS            reduce using rule 43 (atom -> TRUE .)
    MINUS           reduce using rule 43 (atom -> TRUE .)
    LTHAN           reduce using rule 43 (atom -> TRUE .)
    LETHAN          reduce using rule 43 (atom -> TRUE .)
    EQUALS          reduce using rule 43 (atom -> TRUE .)
    DISP            reduce using rule 43 (atom -> TRUE .)
    DOT             reduce using rule 43 (atom -> TRUE .)
    SEMICOLON       reduce using rule 43 (atom -> TRUE .)
    RBRACKET        reduce using rule 43 (atom -> TRUE .)
    THEN            reduce using rule 43 (atom -> TRUE .)
    LOOP            reduce using rule 43 (atom -> TRUE .)
    OF              reduce using rule 43 (atom -> TRUE .)
    COMMA           reduce using rule 43 (atom -> TRUE .)
    IN              reduce using rule 43 (atom -> TRUE .)
    ELSE            reduce using rule 43 (atom -> TRUE .)
    POOL            reduce using rule 43 (atom -> TRUE .)
    FI              reduce using rule 43 (atom -> TRUE .)
    ESAC            reduce using rule 43 (atom -> TRUE .)


state 50

    (44) atom -> FALSE .

    TIMES           reduce using rule 44 (atom -> FALSE .)
    DIVIDE          reduce using rule 44 (atom -> FALSE .)
    PLUS            reduce using rule 44 (atom -> FALSE .)
    MINUS           reduce using rule 44 (atom -> FALSE .)
    LTHAN           reduce using rule 44 (atom -> FALSE .)
    LETHAN          reduce using rule 44 (atom -> FALSE .)
    EQUALS          reduce using rule 44 (atom -> FALSE .)
    DISP            reduce using rule 44 (atom -> FALSE .)
    DOT             reduce using rule 44 (atom -> FALSE .)
    SEMICOLON       reduce using rule 44 (atom -> FALSE .)
    RBRACKET        reduce using rule 44 (atom -> FALSE .)
    THEN            reduce using rule 44 (atom -> FALSE .)
    LOOP            reduce using rule 44 (atom -> FALSE .)
    OF              reduce using rule 44 (atom -> FALSE .)
    COMMA           reduce using rule 44 (atom -> FALSE .)
    IN              reduce using rule 44 (atom -> FALSE .)
    ELSE            reduce using rule 44 (atom -> FALSE .)
    POOL            reduce using rule 44 (atom -> FALSE .)
    FI              reduce using rule 44 (atom -> FALSE .)
    ESAC            reduce using rule 44 (atom -> FALSE .)


state 51

    (45) atom -> ISVOID . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 87
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 52

    (46) atom -> block .

    TIMES           reduce using rule 46 (atom -> block .)
    DIVIDE          reduce using rule 46 (atom -> block .)
    PLUS            reduce using rule 46 (atom -> block .)
    MINUS           reduce using rule 46 (atom -> block .)
    LTHAN           reduce using rule 46 (atom -> block .)
    LETHAN          reduce using rule 46 (atom -> block .)
    EQUALS          reduce using rule 46 (atom -> block .)
    DISP            reduce using rule 46 (atom -> block .)
    DOT             reduce using rule 46 (atom -> block .)
    SEMICOLON       reduce using rule 46 (atom -> block .)
    RBRACKET        reduce using rule 46 (atom -> block .)
    THEN            reduce using rule 46 (atom -> block .)
    LOOP            reduce using rule 46 (atom -> block .)
    OF              reduce using rule 46 (atom -> block .)
    COMMA           reduce using rule 46 (atom -> block .)
    IN              reduce using rule 46 (atom -> block .)
    ELSE            reduce using rule 46 (atom -> block .)
    POOL            reduce using rule 46 (atom -> block .)
    FI              reduce using rule 46 (atom -> block .)
    ESAC            reduce using rule 46 (atom -> block .)


state 53

    (47) atom -> conditional .

    TIMES           reduce using rule 47 (atom -> conditional .)
    DIVIDE          reduce using rule 47 (atom -> conditional .)
    PLUS            reduce using rule 47 (atom -> conditional .)
    MINUS           reduce using rule 47 (atom -> conditional .)
    LTHAN           reduce using rule 47 (atom -> conditional .)
    LETHAN          reduce using rule 47 (atom -> conditional .)
    EQUALS          reduce using rule 47 (atom -> conditional .)
    DISP            reduce using rule 47 (atom -> conditional .)
    DOT             reduce using rule 47 (atom -> conditional .)
    SEMICOLON       reduce using rule 47 (atom -> conditional .)
    RBRACKET        reduce using rule 47 (atom -> conditional .)
    THEN            reduce using rule 47 (atom -> conditional .)
    LOOP            reduce using rule 47 (atom -> conditional .)
    OF              reduce using rule 47 (atom -> conditional .)
    COMMA           reduce using rule 47 (atom -> conditional .)
    IN              reduce using rule 47 (atom -> conditional .)
    ELSE            reduce using rule 47 (atom -> conditional .)
    POOL            reduce using rule 47 (atom -> conditional .)
    FI              reduce using rule 47 (atom -> conditional .)
    ESAC            reduce using rule 47 (atom -> conditional .)


state 54

    (48) atom -> loop .

    TIMES           reduce using rule 48 (atom -> loop .)
    DIVIDE          reduce using rule 48 (atom -> loop .)
    PLUS            reduce using rule 48 (atom -> loop .)
    MINUS           reduce using rule 48 (atom -> loop .)
    LTHAN           reduce using rule 48 (atom -> loop .)
    LETHAN          reduce using rule 48 (atom -> loop .)
    EQUALS          reduce using rule 48 (atom -> loop .)
    DISP            reduce using rule 48 (atom -> loop .)
    DOT             reduce using rule 48 (atom -> loop .)
    SEMICOLON       reduce using rule 48 (atom -> loop .)
    RBRACKET        reduce using rule 48 (atom -> loop .)
    THEN            reduce using rule 48 (atom -> loop .)
    LOOP            reduce using rule 48 (atom -> loop .)
    OF              reduce using rule 48 (atom -> loop .)
    COMMA           reduce using rule 48 (atom -> loop .)
    IN              reduce using rule 48 (atom -> loop .)
    ELSE            reduce using rule 48 (atom -> loop .)
    POOL            reduce using rule 48 (atom -> loop .)
    FI              reduce using rule 48 (atom -> loop .)
    ESAC            reduce using rule 48 (atom -> loop .)


state 55

    (49) atom -> case .

    TIMES           reduce using rule 49 (atom -> case .)
    DIVIDE          reduce using rule 49 (atom -> case .)
    PLUS            reduce using rule 49 (atom -> case .)
    MINUS           reduce using rule 49 (atom -> case .)
    LTHAN           reduce using rule 49 (atom -> case .)
    LETHAN          reduce using rule 49 (atom -> case .)
    EQUALS          reduce using rule 49 (atom -> case .)
    DISP            reduce using rule 49 (atom -> case .)
    DOT             reduce using rule 49 (atom -> case .)
    SEMICOLON       reduce using rule 49 (atom -> case .)
    RBRACKET        reduce using rule 49 (atom -> case .)
    THEN            reduce using rule 49 (atom -> case .)
    LOOP            reduce using rule 49 (atom -> case .)
    OF              reduce using rule 49 (atom -> case .)
    COMMA           reduce using rule 49 (atom -> case .)
    IN              reduce using rule 49 (atom -> case .)
    ELSE            reduce using rule 49 (atom -> case .)
    POOL            reduce using rule 49 (atom -> case .)
    FI              reduce using rule 49 (atom -> case .)
    ESAC            reduce using rule 49 (atom -> case .)


state 56

    (50) atom -> dispatch .

    TIMES           reduce using rule 50 (atom -> dispatch .)
    DIVIDE          reduce using rule 50 (atom -> dispatch .)
    PLUS            reduce using rule 50 (atom -> dispatch .)
    MINUS           reduce using rule 50 (atom -> dispatch .)
    LTHAN           reduce using rule 50 (atom -> dispatch .)
    LETHAN          reduce using rule 50 (atom -> dispatch .)
    EQUALS          reduce using rule 50 (atom -> dispatch .)
    DISP            reduce using rule 50 (atom -> dispatch .)
    DOT             reduce using rule 50 (atom -> dispatch .)
    SEMICOLON       reduce using rule 50 (atom -> dispatch .)
    RBRACKET        reduce using rule 50 (atom -> dispatch .)
    THEN            reduce using rule 50 (atom -> dispatch .)
    LOOP            reduce using rule 50 (atom -> dispatch .)
    OF              reduce using rule 50 (atom -> dispatch .)
    COMMA           reduce using rule 50 (atom -> dispatch .)
    IN              reduce using rule 50 (atom -> dispatch .)
    ELSE            reduce using rule 50 (atom -> dispatch .)
    POOL            reduce using rule 50 (atom -> dispatch .)
    FI              reduce using rule 50 (atom -> dispatch .)
    ESAC            reduce using rule 50 (atom -> dispatch .)


state 57

    (51) atom -> NEW . TYPE

    TYPE            shift and go to state 88


state 58

    (52) atom -> BCOMPLEMENT . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 89
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 59

    (61) let_expression -> LET . declaration_list IN expression
    (62) declaration_list -> . declaration COMMA declaration_list
    (63) declaration_list -> . declaration
    (64) declaration -> . id_type ASSIGN expression
    (65) declaration -> . id_type
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    declaration_list               shift and go to state 90
    declaration                    shift and go to state 91
    id_type                        shift and go to state 92

state 60

    (14) block -> LBRACE . expression_list RBRACE
    (18) expression_list -> . expression SEMICOLON expression_list
    (19) expression_list -> . expression SEMICOLON
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression_list                shift and go to state 93
    expression                     shift and go to state 94
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 61

    (66) conditional -> IF . expression THEN expression ELSE expression FI
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 95
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 62

    (67) loop -> WHILE . expression LOOP expression POOL
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 96
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 63

    (68) case -> CASE . expression OF implications ESAC
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 97
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 64

    (73) dispatch -> dispatch_call .

    TIMES           reduce using rule 73 (dispatch -> dispatch_call .)
    DIVIDE          reduce using rule 73 (dispatch -> dispatch_call .)
    PLUS            reduce using rule 73 (dispatch -> dispatch_call .)
    MINUS           reduce using rule 73 (dispatch -> dispatch_call .)
    LTHAN           reduce using rule 73 (dispatch -> dispatch_call .)
    LETHAN          reduce using rule 73 (dispatch -> dispatch_call .)
    EQUALS          reduce using rule 73 (dispatch -> dispatch_call .)
    DISP            reduce using rule 73 (dispatch -> dispatch_call .)
    DOT             reduce using rule 73 (dispatch -> dispatch_call .)
    SEMICOLON       reduce using rule 73 (dispatch -> dispatch_call .)
    RBRACKET        reduce using rule 73 (dispatch -> dispatch_call .)
    THEN            reduce using rule 73 (dispatch -> dispatch_call .)
    LOOP            reduce using rule 73 (dispatch -> dispatch_call .)
    OF              reduce using rule 73 (dispatch -> dispatch_call .)
    COMMA           reduce using rule 73 (dispatch -> dispatch_call .)
    IN              reduce using rule 73 (dispatch -> dispatch_call .)
    ELSE            reduce using rule 73 (dispatch -> dispatch_call .)
    POOL            reduce using rule 73 (dispatch -> dispatch_call .)
    FI              reduce using rule 73 (dispatch -> dispatch_call .)
    ESAC            reduce using rule 73 (dispatch -> dispatch_call .)


state 65

    (13) method_declaration -> ID LBRACKET formals RBRACKET . TDOTS TYPE block

    TDOTS           shift and go to state 98


state 66

    (15) formals -> id_type COMMA . formals
    (15) formals -> . id_type COMMA formals
    (16) formals -> . id_type
    (17) formals -> . empty
    (12) id_type -> . ID TDOTS TYPE
    (80) empty -> .

    ID              shift and go to state 25
    RBRACKET        reduce using rule 80 (empty -> .)

    id_type                        shift and go to state 27
    formals                        shift and go to state 99
    empty                          shift and go to state 28

state 67

    (72) dispatch -> expression especific . DOT dispatch_call

    DOT             shift and go to state 100


state 68

    (74) especific -> DISP . TYPE

    TYPE            shift and go to state 101


state 69

    (75) especific -> empty .

    DOT             reduce using rule 75 (especific -> empty .)


state 70

    (30) assign -> ID ASSIGN . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 102
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 71

    (76) dispatch_call -> ID LBRACKET . params_expression RBRACKET
    (77) params_expression -> . expression
    (78) params_expression -> . expression COMMA params_expression
    (79) params_expression -> . empty
    (20) expression -> . assign
    (21) expression -> . upper_non
    (80) empty -> .
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACKET        reduce using rule 80 (empty -> .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    params_expression              shift and go to state 103
    expression                     shift and go to state 104
    empty                          shift and go to state 105
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 72

    (22) upper_non -> NOT upper_non .
    (21) expression -> upper_non .

  ! reduce/reduce conflict for DISP resolved using rule 21 (expression -> upper_non .)
  ! reduce/reduce conflict for DOT resolved using rule 21 (expression -> upper_non .)
    SEMICOLON       reduce using rule 22 (upper_non -> NOT upper_non .)
    RBRACKET        reduce using rule 22 (upper_non -> NOT upper_non .)
    TIMES           reduce using rule 22 (upper_non -> NOT upper_non .)
    DIVIDE          reduce using rule 22 (upper_non -> NOT upper_non .)
    PLUS            reduce using rule 22 (upper_non -> NOT upper_non .)
    MINUS           reduce using rule 22 (upper_non -> NOT upper_non .)
    LTHAN           reduce using rule 22 (upper_non -> NOT upper_non .)
    LETHAN          reduce using rule 22 (upper_non -> NOT upper_non .)
    EQUALS          reduce using rule 22 (upper_non -> NOT upper_non .)
    THEN            reduce using rule 22 (upper_non -> NOT upper_non .)
    LOOP            reduce using rule 22 (upper_non -> NOT upper_non .)
    OF              reduce using rule 22 (upper_non -> NOT upper_non .)
    COMMA           reduce using rule 22 (upper_non -> NOT upper_non .)
    IN              reduce using rule 22 (upper_non -> NOT upper_non .)
    ELSE            reduce using rule 22 (upper_non -> NOT upper_non .)
    POOL            reduce using rule 22 (upper_non -> NOT upper_non .)
    FI              reduce using rule 22 (upper_non -> NOT upper_non .)
    ESAC            reduce using rule 22 (upper_non -> NOT upper_non .)
    DISP            reduce using rule 21 (expression -> upper_non .)
    DOT             reduce using rule 21 (expression -> upper_non .)

  ! DISP            [ reduce using rule 22 (upper_non -> NOT upper_non .) ]
  ! DOT             [ reduce using rule 22 (upper_non -> NOT upper_non .) ]


state 73

    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 74

    (42) atom -> ID .
    (76) dispatch_call -> ID . LBRACKET params_expression RBRACKET
    (30) assign -> ID . ASSIGN expression

    DISP            reduce using rule 42 (atom -> ID .)
    DOT             reduce using rule 42 (atom -> ID .)
    SEMICOLON       reduce using rule 42 (atom -> ID .)
    RBRACKET        reduce using rule 42 (atom -> ID .)
    TIMES           reduce using rule 42 (atom -> ID .)
    DIVIDE          reduce using rule 42 (atom -> ID .)
    PLUS            reduce using rule 42 (atom -> ID .)
    MINUS           reduce using rule 42 (atom -> ID .)
    LTHAN           reduce using rule 42 (atom -> ID .)
    LETHAN          reduce using rule 42 (atom -> ID .)
    EQUALS          reduce using rule 42 (atom -> ID .)
    THEN            reduce using rule 42 (atom -> ID .)
    LOOP            reduce using rule 42 (atom -> ID .)
    OF              reduce using rule 42 (atom -> ID .)
    COMMA           reduce using rule 42 (atom -> ID .)
    IN              reduce using rule 42 (atom -> ID .)
    ELSE            reduce using rule 42 (atom -> ID .)
    POOL            reduce using rule 42 (atom -> ID .)
    FI              reduce using rule 42 (atom -> ID .)
    ESAC            reduce using rule 42 (atom -> ID .)
    LBRACKET        shift and go to state 71
    ASSIGN          shift and go to state 70


state 75

    (24) operator_non -> k_arith LTHAN . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 106
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 76

    (25) operator_non -> k_arith LETHAN . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 107
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 77

    (26) operator_non -> k_arith EQUALS . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 108
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 78

    (31) arith -> arith PLUS . term
    (53) e_arith -> arith PLUS . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    arith                          shift and go to state 37
    term                           shift and go to state 109
    e_term                         shift and go to state 110
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    e_arith                        shift and go to state 38

state 79

    (32) arith -> arith MINUS . term
    (54) e_arith -> arith MINUS . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    arith                          shift and go to state 37
    term                           shift and go to state 111
    e_term                         shift and go to state 112
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    e_arith                        shift and go to state 38

state 80

    (34) term -> term TIMES . factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34
    LET             shift and go to state 59

    term                           shift and go to state 39
    factor                         shift and go to state 113
    atom                           shift and go to state 44
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    e_term                         shift and go to state 41
    e_factor                       shift and go to state 43
    let_expression                 shift and go to state 45

state 81

    (35) term -> term DIVIDE . factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (20) expression -> . assign
    (21) expression -> . upper_non
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    ID              shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34
    LET             shift and go to state 59

    term                           shift and go to state 39
    factor                         shift and go to state 114
    atom                           shift and go to state 44
    expression                     shift and go to state 73
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    e_term                         shift and go to state 41
    e_factor                       shift and go to state 43
    let_expression                 shift and go to state 45

state 82

    (37) factor -> MINUS factor .
    (36) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for DISP resolved using rule 36 (term -> factor .)
  ! reduce/reduce conflict for DOT resolved using rule 36 (term -> factor .)
    SEMICOLON       reduce using rule 37 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 37 (factor -> MINUS factor .)
    THEN            reduce using rule 37 (factor -> MINUS factor .)
    LOOP            reduce using rule 37 (factor -> MINUS factor .)
    OF              reduce using rule 37 (factor -> MINUS factor .)
    COMMA           reduce using rule 37 (factor -> MINUS factor .)
    IN              reduce using rule 37 (factor -> MINUS factor .)
    ELSE            reduce using rule 37 (factor -> MINUS factor .)
    POOL            reduce using rule 37 (factor -> MINUS factor .)
    FI              reduce using rule 37 (factor -> MINUS factor .)
    ESAC            reduce using rule 37 (factor -> MINUS factor .)
    TIMES           reduce using rule 36 (term -> factor .)
    DIVIDE          reduce using rule 36 (term -> factor .)
    PLUS            reduce using rule 36 (term -> factor .)
    MINUS           reduce using rule 36 (term -> factor .)
    LTHAN           reduce using rule 36 (term -> factor .)
    LETHAN          reduce using rule 36 (term -> factor .)
    EQUALS          reduce using rule 36 (term -> factor .)
    DISP            reduce using rule 36 (term -> factor .)
    DOT             reduce using rule 36 (term -> factor .)

  ! TIMES           [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! DIVIDE          [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! PLUS            [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! MINUS           [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! LTHAN           [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! LETHAN          [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! EQUALS          [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! DISP            [ reduce using rule 37 (factor -> MINUS factor .) ]
  ! DOT             [ reduce using rule 37 (factor -> MINUS factor .) ]


state 83

    (59) e_factor -> MINUS e_factor .
    (58) e_term -> e_factor .

  ! reduce/reduce conflict for TIMES resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DISP resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DOT resolved using rule 58 (e_term -> e_factor .)
    SEMICOLON       reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACKET        reduce using rule 59 (e_factor -> MINUS e_factor .)
    PLUS            reduce using rule 59 (e_factor -> MINUS e_factor .)
    MINUS           reduce using rule 59 (e_factor -> MINUS e_factor .)
    THEN            reduce using rule 59 (e_factor -> MINUS e_factor .)
    LOOP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    OF              reduce using rule 59 (e_factor -> MINUS e_factor .)
    COMMA           reduce using rule 59 (e_factor -> MINUS e_factor .)
    IN              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ELSE            reduce using rule 59 (e_factor -> MINUS e_factor .)
    POOL            reduce using rule 59 (e_factor -> MINUS e_factor .)
    FI              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ESAC            reduce using rule 59 (e_factor -> MINUS e_factor .)
    TIMES           reduce using rule 58 (e_term -> e_factor .)
    DIVIDE          reduce using rule 58 (e_term -> e_factor .)
    LTHAN           reduce using rule 58 (e_term -> e_factor .)
    LETHAN          reduce using rule 58 (e_term -> e_factor .)
    EQUALS          reduce using rule 58 (e_term -> e_factor .)
    DISP            reduce using rule 58 (e_term -> e_factor .)
    DOT             reduce using rule 58 (e_term -> e_factor .)

  ! TIMES           [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DIVIDE          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! LTHAN           [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! LETHAN          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! EQUALS          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DISP            [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DOT             [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]


state 84

    (56) e_term -> e_term TIMES . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 116
    LET             shift and go to state 59

    e_factor                       shift and go to state 115
    let_expression                 shift and go to state 45

state 85

    (57) e_term -> e_term DIVIDE . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 116
    LET             shift and go to state 59

    e_factor                       shift and go to state 117
    let_expression                 shift and go to state 45

state 86

    (39) atom -> LBRACKET expression . RBRACKET
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    RBRACKET        shift and go to state 118
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 87

    (45) atom -> ISVOID expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 45 (atom -> ISVOID expression .)
    TIMES           reduce using rule 45 (atom -> ISVOID expression .)
    DIVIDE          reduce using rule 45 (atom -> ISVOID expression .)
    PLUS            reduce using rule 45 (atom -> ISVOID expression .)
    MINUS           reduce using rule 45 (atom -> ISVOID expression .)
    LTHAN           reduce using rule 45 (atom -> ISVOID expression .)
    LETHAN          reduce using rule 45 (atom -> ISVOID expression .)
    EQUALS          reduce using rule 45 (atom -> ISVOID expression .)
    DOT             reduce using rule 45 (atom -> ISVOID expression .)
    SEMICOLON       reduce using rule 45 (atom -> ISVOID expression .)
    RBRACKET        reduce using rule 45 (atom -> ISVOID expression .)
    THEN            reduce using rule 45 (atom -> ISVOID expression .)
    LOOP            reduce using rule 45 (atom -> ISVOID expression .)
    OF              reduce using rule 45 (atom -> ISVOID expression .)
    COMMA           reduce using rule 45 (atom -> ISVOID expression .)
    IN              reduce using rule 45 (atom -> ISVOID expression .)
    ELSE            reduce using rule 45 (atom -> ISVOID expression .)
    POOL            reduce using rule 45 (atom -> ISVOID expression .)
    FI              reduce using rule 45 (atom -> ISVOID expression .)
    ESAC            reduce using rule 45 (atom -> ISVOID expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 45 (atom -> ISVOID expression .) ]
  ! DOT             [ reduce using rule 80 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 88

    (51) atom -> NEW TYPE .

    TIMES           reduce using rule 51 (atom -> NEW TYPE .)
    DIVIDE          reduce using rule 51 (atom -> NEW TYPE .)
    PLUS            reduce using rule 51 (atom -> NEW TYPE .)
    MINUS           reduce using rule 51 (atom -> NEW TYPE .)
    LTHAN           reduce using rule 51 (atom -> NEW TYPE .)
    LETHAN          reduce using rule 51 (atom -> NEW TYPE .)
    EQUALS          reduce using rule 51 (atom -> NEW TYPE .)
    DISP            reduce using rule 51 (atom -> NEW TYPE .)
    DOT             reduce using rule 51 (atom -> NEW TYPE .)
    SEMICOLON       reduce using rule 51 (atom -> NEW TYPE .)
    RBRACKET        reduce using rule 51 (atom -> NEW TYPE .)
    THEN            reduce using rule 51 (atom -> NEW TYPE .)
    LOOP            reduce using rule 51 (atom -> NEW TYPE .)
    OF              reduce using rule 51 (atom -> NEW TYPE .)
    COMMA           reduce using rule 51 (atom -> NEW TYPE .)
    IN              reduce using rule 51 (atom -> NEW TYPE .)
    ELSE            reduce using rule 51 (atom -> NEW TYPE .)
    POOL            reduce using rule 51 (atom -> NEW TYPE .)
    FI              reduce using rule 51 (atom -> NEW TYPE .)
    ESAC            reduce using rule 51 (atom -> NEW TYPE .)


state 89

    (52) atom -> BCOMPLEMENT expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 52 (atom -> BCOMPLEMENT expression .)
    TIMES           reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    DIVIDE          reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    PLUS            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    MINUS           reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    LTHAN           reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    LETHAN          reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    EQUALS          reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    DOT             reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    SEMICOLON       reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    RBRACKET        reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    THEN            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    LOOP            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    OF              reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    COMMA           reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    IN              reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    ELSE            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    POOL            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    FI              reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    ESAC            reduce using rule 52 (atom -> BCOMPLEMENT expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 52 (atom -> BCOMPLEMENT expression .) ]
  ! DOT             [ reduce using rule 80 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 90

    (61) let_expression -> LET declaration_list . IN expression

    IN              shift and go to state 119


state 91

    (62) declaration_list -> declaration . COMMA declaration_list
    (63) declaration_list -> declaration .

    COMMA           shift and go to state 120
    IN              reduce using rule 63 (declaration_list -> declaration .)


state 92

    (64) declaration -> id_type . ASSIGN expression
    (65) declaration -> id_type .

    ASSIGN          shift and go to state 121
    COMMA           reduce using rule 65 (declaration -> id_type .)
    IN              reduce using rule 65 (declaration -> id_type .)


state 93

    (14) block -> LBRACE expression_list . RBRACE

    RBRACE          shift and go to state 122


state 94

    (18) expression_list -> expression . SEMICOLON expression_list
    (19) expression_list -> expression . SEMICOLON
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    SEMICOLON       shift and go to state 123
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 95

    (66) conditional -> IF expression . THEN expression ELSE expression FI
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    THEN            shift and go to state 124
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 96

    (67) loop -> WHILE expression . LOOP expression POOL
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    LOOP            shift and go to state 125
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 97

    (68) case -> CASE expression . OF implications ESAC
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    OF              shift and go to state 126
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 98

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS . TYPE block

    TYPE            shift and go to state 127


state 99

    (15) formals -> id_type COMMA formals .

    RBRACKET        reduce using rule 15 (formals -> id_type COMMA formals .)


state 100

    (72) dispatch -> expression especific DOT . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 129

    dispatch_call                  shift and go to state 128

state 101

    (74) especific -> DISP TYPE .

    DOT             reduce using rule 74 (especific -> DISP TYPE .)


state 102

    (30) assign -> ID ASSIGN expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 30 (assign -> ID ASSIGN expression .)
    DOT             reduce using rule 30 (assign -> ID ASSIGN expression .)
    SEMICOLON       reduce using rule 30 (assign -> ID ASSIGN expression .)
    RBRACKET        reduce using rule 30 (assign -> ID ASSIGN expression .)
    TIMES           reduce using rule 30 (assign -> ID ASSIGN expression .)
    DIVIDE          reduce using rule 30 (assign -> ID ASSIGN expression .)
    PLUS            reduce using rule 30 (assign -> ID ASSIGN expression .)
    MINUS           reduce using rule 30 (assign -> ID ASSIGN expression .)
    LTHAN           reduce using rule 30 (assign -> ID ASSIGN expression .)
    LETHAN          reduce using rule 30 (assign -> ID ASSIGN expression .)
    EQUALS          reduce using rule 30 (assign -> ID ASSIGN expression .)
    THEN            reduce using rule 30 (assign -> ID ASSIGN expression .)
    LOOP            reduce using rule 30 (assign -> ID ASSIGN expression .)
    OF              reduce using rule 30 (assign -> ID ASSIGN expression .)
    COMMA           reduce using rule 30 (assign -> ID ASSIGN expression .)
    IN              reduce using rule 30 (assign -> ID ASSIGN expression .)
    ELSE            reduce using rule 30 (assign -> ID ASSIGN expression .)
    POOL            reduce using rule 30 (assign -> ID ASSIGN expression .)
    FI              reduce using rule 30 (assign -> ID ASSIGN expression .)
    ESAC            reduce using rule 30 (assign -> ID ASSIGN expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 30 (assign -> ID ASSIGN expression .) ]
  ! DOT             [ reduce using rule 80 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 103

    (76) dispatch_call -> ID LBRACKET params_expression . RBRACKET

    RBRACKET        shift and go to state 130


state 104

    (77) params_expression -> expression .
    (78) params_expression -> expression . COMMA params_expression
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    RBRACKET        reduce using rule 77 (params_expression -> expression .)
    COMMA           shift and go to state 131
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 105

    (79) params_expression -> empty .

    RBRACKET        reduce using rule 79 (params_expression -> empty .)


state 106

    (24) operator_non -> k_arith LTHAN k_arith .
    (24) operator_non -> k_arith . LTHAN k_arith
    (25) operator_non -> k_arith . LETHAN k_arith
    (26) operator_non -> k_arith . EQUALS k_arith
    (27) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 24 (operator_non -> k_arith LTHAN k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    DISP            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    DOT             reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    SEMICOLON       reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    RBRACKET        reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    TIMES           reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    DIVIDE          reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    PLUS            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    MINUS           reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    LTHAN           reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    LETHAN          reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    EQUALS          reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    THEN            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    LOOP            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    OF              reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    COMMA           reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    IN              reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    ELSE            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    POOL            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    FI              reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)
    ESAC            reduce using rule 24 (operator_non -> k_arith LTHAN k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 27 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 27 (operator_non -> k_arith .) ]


state 107

    (25) operator_non -> k_arith LETHAN k_arith .
    (24) operator_non -> k_arith . LTHAN k_arith
    (25) operator_non -> k_arith . LETHAN k_arith
    (26) operator_non -> k_arith . EQUALS k_arith
    (27) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 25 (operator_non -> k_arith LETHAN k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    DISP            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    DOT             reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    SEMICOLON       reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    RBRACKET        reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    TIMES           reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    DIVIDE          reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    PLUS            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    MINUS           reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    LTHAN           reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    LETHAN          reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    EQUALS          reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    THEN            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    LOOP            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    OF              reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    COMMA           reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    IN              reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    ELSE            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    POOL            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    FI              reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)
    ESAC            reduce using rule 25 (operator_non -> k_arith LETHAN k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 27 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 27 (operator_non -> k_arith .) ]


state 108

    (26) operator_non -> k_arith EQUALS k_arith .
    (24) operator_non -> k_arith . LTHAN k_arith
    (25) operator_non -> k_arith . LETHAN k_arith
    (26) operator_non -> k_arith . EQUALS k_arith
    (27) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 26 (operator_non -> k_arith EQUALS k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    DISP            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    DOT             reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    SEMICOLON       reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    RBRACKET        reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    TIMES           reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    DIVIDE          reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    PLUS            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    MINUS           reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    LTHAN           reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    LETHAN          reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    EQUALS          reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    THEN            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    LOOP            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    OF              reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    COMMA           reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    IN              reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    ELSE            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    POOL            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    FI              reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)
    ESAC            reduce using rule 26 (operator_non -> k_arith EQUALS k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 27 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 27 (operator_non -> k_arith .) ]


state 109

    (31) arith -> arith PLUS term .
    (34) term -> term . TIMES factor
    (35) term -> term . DIVIDE factor
    (33) arith -> term .

  ! reduce/reduce conflict for PLUS resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for LTHAN resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for DISP resolved using rule 31 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for DOT resolved using rule 31 (arith -> arith PLUS term .)
    PLUS            reduce using rule 31 (arith -> arith PLUS term .)
    MINUS           reduce using rule 31 (arith -> arith PLUS term .)
    LTHAN           reduce using rule 31 (arith -> arith PLUS term .)
    LETHAN          reduce using rule 31 (arith -> arith PLUS term .)
    EQUALS          reduce using rule 31 (arith -> arith PLUS term .)
    DISP            reduce using rule 31 (arith -> arith PLUS term .)
    DOT             reduce using rule 31 (arith -> arith PLUS term .)
    SEMICOLON       reduce using rule 31 (arith -> arith PLUS term .)
    RBRACKET        reduce using rule 31 (arith -> arith PLUS term .)
    THEN            reduce using rule 31 (arith -> arith PLUS term .)
    LOOP            reduce using rule 31 (arith -> arith PLUS term .)
    OF              reduce using rule 31 (arith -> arith PLUS term .)
    COMMA           reduce using rule 31 (arith -> arith PLUS term .)
    IN              reduce using rule 31 (arith -> arith PLUS term .)
    ELSE            reduce using rule 31 (arith -> arith PLUS term .)
    POOL            reduce using rule 31 (arith -> arith PLUS term .)
    FI              reduce using rule 31 (arith -> arith PLUS term .)
    ESAC            reduce using rule 31 (arith -> arith PLUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 31 (arith -> arith PLUS term .) ]
  ! DIVIDE          [ reduce using rule 31 (arith -> arith PLUS term .) ]
  ! PLUS            [ reduce using rule 33 (arith -> term .) ]
  ! MINUS           [ reduce using rule 33 (arith -> term .) ]
  ! LTHAN           [ reduce using rule 33 (arith -> term .) ]
  ! LETHAN          [ reduce using rule 33 (arith -> term .) ]
  ! EQUALS          [ reduce using rule 33 (arith -> term .) ]
  ! DISP            [ reduce using rule 33 (arith -> term .) ]
  ! DOT             [ reduce using rule 33 (arith -> term .) ]


state 110

    (53) e_arith -> arith PLUS e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor
    (55) e_arith -> e_term .

  ! reduce/reduce conflict for LTHAN resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for DISP resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for DOT resolved using rule 53 (e_arith -> arith PLUS e_term .)
    LTHAN           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    LETHAN          reduce using rule 53 (e_arith -> arith PLUS e_term .)
    EQUALS          reduce using rule 53 (e_arith -> arith PLUS e_term .)
    DISP            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    DOT             reduce using rule 53 (e_arith -> arith PLUS e_term .)
    SEMICOLON       reduce using rule 53 (e_arith -> arith PLUS e_term .)
    RBRACKET        reduce using rule 53 (e_arith -> arith PLUS e_term .)
    PLUS            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    MINUS           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    THEN            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    LOOP            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    OF              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    COMMA           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    IN              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    ELSE            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    POOL            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    FI              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    ESAC            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 53 (e_arith -> arith PLUS e_term .) ]
  ! DIVIDE          [ reduce using rule 53 (e_arith -> arith PLUS e_term .) ]
  ! LTHAN           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! LETHAN          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! EQUALS          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DISP            [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DOT             [ reduce using rule 55 (e_arith -> e_term .) ]


state 111

    (32) arith -> arith MINUS term .
    (34) term -> term . TIMES factor
    (35) term -> term . DIVIDE factor
    (33) arith -> term .

  ! reduce/reduce conflict for PLUS resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for LTHAN resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for DISP resolved using rule 32 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for DOT resolved using rule 32 (arith -> arith MINUS term .)
    PLUS            reduce using rule 32 (arith -> arith MINUS term .)
    MINUS           reduce using rule 32 (arith -> arith MINUS term .)
    LTHAN           reduce using rule 32 (arith -> arith MINUS term .)
    LETHAN          reduce using rule 32 (arith -> arith MINUS term .)
    EQUALS          reduce using rule 32 (arith -> arith MINUS term .)
    DISP            reduce using rule 32 (arith -> arith MINUS term .)
    DOT             reduce using rule 32 (arith -> arith MINUS term .)
    SEMICOLON       reduce using rule 32 (arith -> arith MINUS term .)
    RBRACKET        reduce using rule 32 (arith -> arith MINUS term .)
    THEN            reduce using rule 32 (arith -> arith MINUS term .)
    LOOP            reduce using rule 32 (arith -> arith MINUS term .)
    OF              reduce using rule 32 (arith -> arith MINUS term .)
    COMMA           reduce using rule 32 (arith -> arith MINUS term .)
    IN              reduce using rule 32 (arith -> arith MINUS term .)
    ELSE            reduce using rule 32 (arith -> arith MINUS term .)
    POOL            reduce using rule 32 (arith -> arith MINUS term .)
    FI              reduce using rule 32 (arith -> arith MINUS term .)
    ESAC            reduce using rule 32 (arith -> arith MINUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 32 (arith -> arith MINUS term .) ]
  ! DIVIDE          [ reduce using rule 32 (arith -> arith MINUS term .) ]
  ! PLUS            [ reduce using rule 33 (arith -> term .) ]
  ! MINUS           [ reduce using rule 33 (arith -> term .) ]
  ! LTHAN           [ reduce using rule 33 (arith -> term .) ]
  ! LETHAN          [ reduce using rule 33 (arith -> term .) ]
  ! EQUALS          [ reduce using rule 33 (arith -> term .) ]
  ! DISP            [ reduce using rule 33 (arith -> term .) ]
  ! DOT             [ reduce using rule 33 (arith -> term .) ]


state 112

    (54) e_arith -> arith MINUS e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor
    (55) e_arith -> e_term .

  ! reduce/reduce conflict for LTHAN resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for DISP resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for DOT resolved using rule 54 (e_arith -> arith MINUS e_term .)
    LTHAN           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    LETHAN          reduce using rule 54 (e_arith -> arith MINUS e_term .)
    EQUALS          reduce using rule 54 (e_arith -> arith MINUS e_term .)
    DISP            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    DOT             reduce using rule 54 (e_arith -> arith MINUS e_term .)
    SEMICOLON       reduce using rule 54 (e_arith -> arith MINUS e_term .)
    RBRACKET        reduce using rule 54 (e_arith -> arith MINUS e_term .)
    PLUS            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    MINUS           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    THEN            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    LOOP            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    OF              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    COMMA           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    IN              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    ELSE            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    POOL            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    FI              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    ESAC            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 54 (e_arith -> arith MINUS e_term .) ]
  ! DIVIDE          [ reduce using rule 54 (e_arith -> arith MINUS e_term .) ]
  ! LTHAN           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! LETHAN          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! EQUALS          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DISP            [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DOT             [ reduce using rule 55 (e_arith -> e_term .) ]


state 113

    (34) term -> term TIMES factor .
    (36) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DISP resolved using rule 34 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DOT resolved using rule 34 (term -> term TIMES factor .)
    TIMES           reduce using rule 34 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 34 (term -> term TIMES factor .)
    PLUS            reduce using rule 34 (term -> term TIMES factor .)
    MINUS           reduce using rule 34 (term -> term TIMES factor .)
    LTHAN           reduce using rule 34 (term -> term TIMES factor .)
    LETHAN          reduce using rule 34 (term -> term TIMES factor .)
    EQUALS          reduce using rule 34 (term -> term TIMES factor .)
    DISP            reduce using rule 34 (term -> term TIMES factor .)
    DOT             reduce using rule 34 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 34 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 34 (term -> term TIMES factor .)
    THEN            reduce using rule 34 (term -> term TIMES factor .)
    LOOP            reduce using rule 34 (term -> term TIMES factor .)
    OF              reduce using rule 34 (term -> term TIMES factor .)
    COMMA           reduce using rule 34 (term -> term TIMES factor .)
    IN              reduce using rule 34 (term -> term TIMES factor .)
    ELSE            reduce using rule 34 (term -> term TIMES factor .)
    POOL            reduce using rule 34 (term -> term TIMES factor .)
    FI              reduce using rule 34 (term -> term TIMES factor .)
    ESAC            reduce using rule 34 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 36 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 36 (term -> factor .) ]
  ! PLUS            [ reduce using rule 36 (term -> factor .) ]
  ! MINUS           [ reduce using rule 36 (term -> factor .) ]
  ! LTHAN           [ reduce using rule 36 (term -> factor .) ]
  ! LETHAN          [ reduce using rule 36 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 36 (term -> factor .) ]
  ! DISP            [ reduce using rule 36 (term -> factor .) ]
  ! DOT             [ reduce using rule 36 (term -> factor .) ]


state 114

    (35) term -> term DIVIDE factor .
    (36) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DISP resolved using rule 35 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DOT resolved using rule 35 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 35 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 35 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 35 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 35 (term -> term DIVIDE factor .)
    LTHAN           reduce using rule 35 (term -> term DIVIDE factor .)
    LETHAN          reduce using rule 35 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 35 (term -> term DIVIDE factor .)
    DISP            reduce using rule 35 (term -> term DIVIDE factor .)
    DOT             reduce using rule 35 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 35 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 35 (term -> term DIVIDE factor .)
    THEN            reduce using rule 35 (term -> term DIVIDE factor .)
    LOOP            reduce using rule 35 (term -> term DIVIDE factor .)
    OF              reduce using rule 35 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 35 (term -> term DIVIDE factor .)
    IN              reduce using rule 35 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 35 (term -> term DIVIDE factor .)
    POOL            reduce using rule 35 (term -> term DIVIDE factor .)
    FI              reduce using rule 35 (term -> term DIVIDE factor .)
    ESAC            reduce using rule 35 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 36 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 36 (term -> factor .) ]
  ! PLUS            [ reduce using rule 36 (term -> factor .) ]
  ! MINUS           [ reduce using rule 36 (term -> factor .) ]
  ! LTHAN           [ reduce using rule 36 (term -> factor .) ]
  ! LETHAN          [ reduce using rule 36 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 36 (term -> factor .) ]
  ! DISP            [ reduce using rule 36 (term -> factor .) ]
  ! DOT             [ reduce using rule 36 (term -> factor .) ]


state 115

    (56) e_term -> e_term TIMES e_factor .

    TIMES           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DIVIDE          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LTHAN           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LETHAN          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    EQUALS          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DISP            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DOT             reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    SEMICOLON       reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    RBRACKET        reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    PLUS            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    MINUS           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    THEN            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LOOP            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    OF              reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    COMMA           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    IN              reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    ELSE            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    POOL            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    FI              reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    ESAC            reduce using rule 56 (e_term -> e_term TIMES e_factor .)


state 116

    (59) e_factor -> MINUS . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 116
    LET             shift and go to state 59

    e_factor                       shift and go to state 132
    let_expression                 shift and go to state 45

state 117

    (57) e_term -> e_term DIVIDE e_factor .

    TIMES           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DIVIDE          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LTHAN           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LETHAN          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    EQUALS          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DISP            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DOT             reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    SEMICOLON       reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    RBRACKET        reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    PLUS            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    MINUS           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    THEN            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LOOP            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    OF              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    COMMA           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    IN              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    ELSE            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    POOL            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    FI              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    ESAC            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)


state 118

    (39) atom -> LBRACKET expression RBRACKET .

    TIMES           reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    LTHAN           reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    LETHAN          reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    EQUALS          reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    DISP            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    DOT             reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    THEN            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    LOOP            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    OF              reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    IN              reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    POOL            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    FI              reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)
    ESAC            reduce using rule 39 (atom -> LBRACKET expression RBRACKET .)


state 119

    (61) let_expression -> LET declaration_list IN . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 133
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 120

    (62) declaration_list -> declaration COMMA . declaration_list
    (62) declaration_list -> . declaration COMMA declaration_list
    (63) declaration_list -> . declaration
    (64) declaration -> . id_type ASSIGN expression
    (65) declaration -> . id_type
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    declaration                    shift and go to state 91
    declaration_list               shift and go to state 134
    id_type                        shift and go to state 92

state 121

    (64) declaration -> id_type ASSIGN . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 135
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 122

    (14) block -> LBRACE expression_list RBRACE .

    TIMES           reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    LTHAN           reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    LETHAN          reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    EQUALS          reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    DISP            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    DOT             reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    THEN            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    LOOP            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    OF              reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    IN              reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    ELSE            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    POOL            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    FI              reduce using rule 14 (block -> LBRACE expression_list RBRACE .)
    ESAC            reduce using rule 14 (block -> LBRACE expression_list RBRACE .)


state 123

    (18) expression_list -> expression SEMICOLON . expression_list
    (19) expression_list -> expression SEMICOLON .
    (18) expression_list -> . expression SEMICOLON expression_list
    (19) expression_list -> . expression SEMICOLON
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACE          reduce using rule 19 (expression_list -> expression SEMICOLON .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 94
    expression_list                shift and go to state 136
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 124

    (66) conditional -> IF expression THEN . expression ELSE expression FI
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 137
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 125

    (67) loop -> WHILE expression LOOP . expression POOL
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 138
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 126

    (68) case -> CASE expression OF . implications ESAC
    (69) implications -> . implication COMMA implications
    (70) implications -> . implication
    (71) implication -> . id_type IMPLY expression
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    implications                   shift and go to state 139
    implication                    shift and go to state 140
    id_type                        shift and go to state 141

state 127

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE . block
    (14) block -> . LBRACE expression_list RBRACE

    LBRACE          shift and go to state 60

    block                          shift and go to state 142

state 128

    (72) dispatch -> expression especific DOT dispatch_call .

    TIMES           reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    DIVIDE          reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    PLUS            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    MINUS           reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    LTHAN           reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    LETHAN          reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    EQUALS          reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    DISP            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    DOT             reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    SEMICOLON       reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    RBRACKET        reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    THEN            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    LOOP            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    OF              reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    COMMA           reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    IN              reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    ELSE            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    POOL            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    FI              reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)
    ESAC            reduce using rule 72 (dispatch -> expression especific DOT dispatch_call .)


state 129

    (76) dispatch_call -> ID . LBRACKET params_expression RBRACKET

    LBRACKET        shift and go to state 71


state 130

    (76) dispatch_call -> ID LBRACKET params_expression RBRACKET .

    TIMES           reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DIVIDE          reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    PLUS            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    MINUS           reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LTHAN           reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LETHAN          reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    EQUALS          reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DISP            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DOT             reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    SEMICOLON       reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    RBRACKET        reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    THEN            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LOOP            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    OF              reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    COMMA           reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    IN              reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    ELSE            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    POOL            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    FI              reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    ESAC            reduce using rule 76 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)


state 131

    (78) params_expression -> expression COMMA . params_expression
    (77) params_expression -> . expression
    (78) params_expression -> . expression COMMA params_expression
    (79) params_expression -> . empty
    (20) expression -> . assign
    (21) expression -> . upper_non
    (80) empty -> .
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACKET        reduce using rule 80 (empty -> .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 104
    params_expression              shift and go to state 143
    empty                          shift and go to state 105
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 132

    (59) e_factor -> MINUS e_factor .

    DISP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    DOT             reduce using rule 59 (e_factor -> MINUS e_factor .)
    SEMICOLON       reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACKET        reduce using rule 59 (e_factor -> MINUS e_factor .)
    TIMES           reduce using rule 59 (e_factor -> MINUS e_factor .)
    DIVIDE          reduce using rule 59 (e_factor -> MINUS e_factor .)
    PLUS            reduce using rule 59 (e_factor -> MINUS e_factor .)
    MINUS           reduce using rule 59 (e_factor -> MINUS e_factor .)
    LTHAN           reduce using rule 59 (e_factor -> MINUS e_factor .)
    LETHAN          reduce using rule 59 (e_factor -> MINUS e_factor .)
    EQUALS          reduce using rule 59 (e_factor -> MINUS e_factor .)
    THEN            reduce using rule 59 (e_factor -> MINUS e_factor .)
    LOOP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    OF              reduce using rule 59 (e_factor -> MINUS e_factor .)
    COMMA           reduce using rule 59 (e_factor -> MINUS e_factor .)
    IN              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ELSE            reduce using rule 59 (e_factor -> MINUS e_factor .)
    POOL            reduce using rule 59 (e_factor -> MINUS e_factor .)
    FI              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ESAC            reduce using rule 59 (e_factor -> MINUS e_factor .)


state 133

    (61) let_expression -> LET declaration_list IN expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

  ! shift/reduce conflict for DISP resolved as shift
  ! reduce/reduce conflict for DOT resolved using rule 61 (let_expression -> LET declaration_list IN expression .)
    TIMES           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DIVIDE          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LTHAN           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LETHAN          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    EQUALS          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DOT             reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    SEMICOLON       reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    RBRACKET        reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    PLUS            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    MINUS           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    THEN            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LOOP            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    OF              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    COMMA           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    IN              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    ELSE            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    POOL            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    FI              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    ESAC            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 61 (let_expression -> LET declaration_list IN expression .) ]
  ! DOT             [ reduce using rule 80 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 134

    (62) declaration_list -> declaration COMMA declaration_list .

    IN              reduce using rule 62 (declaration_list -> declaration COMMA declaration_list .)


state 135

    (64) declaration -> id_type ASSIGN expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    COMMA           reduce using rule 64 (declaration -> id_type ASSIGN expression .)
    IN              reduce using rule 64 (declaration -> id_type ASSIGN expression .)
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 136

    (18) expression_list -> expression SEMICOLON expression_list .

    RBRACE          reduce using rule 18 (expression_list -> expression SEMICOLON expression_list .)


state 137

    (66) conditional -> IF expression THEN expression . ELSE expression FI
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    ELSE            shift and go to state 144
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 138

    (67) loop -> WHILE expression LOOP expression . POOL
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    POOL            shift and go to state 145
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 139

    (68) case -> CASE expression OF implications . ESAC

    ESAC            shift and go to state 146


state 140

    (69) implications -> implication . COMMA implications
    (70) implications -> implication .

    COMMA           shift and go to state 147
    ESAC            reduce using rule 70 (implications -> implication .)


state 141

    (71) implication -> id_type . IMPLY expression

    IMPLY           shift and go to state 148


state 142

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE block .

    SEMICOLON       reduce using rule 13 (method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE block .)


state 143

    (78) params_expression -> expression COMMA params_expression .

    RBRACKET        reduce using rule 78 (params_expression -> expression COMMA params_expression .)


state 144

    (66) conditional -> IF expression THEN expression ELSE . expression FI
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 149
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 145

    (67) loop -> WHILE expression LOOP expression POOL .

    TIMES           reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    DIVIDE          reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    PLUS            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    MINUS           reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    LTHAN           reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    LETHAN          reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    EQUALS          reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    DISP            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    DOT             reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    SEMICOLON       reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    RBRACKET        reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    THEN            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    LOOP            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    OF              reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    COMMA           reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    IN              reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    ELSE            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    POOL            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    FI              reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)
    ESAC            reduce using rule 67 (loop -> WHILE expression LOOP expression POOL .)


state 146

    (68) case -> CASE expression OF implications ESAC .

    TIMES           reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    DIVIDE          reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    PLUS            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    MINUS           reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    LTHAN           reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    LETHAN          reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    EQUALS          reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    DISP            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    DOT             reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    SEMICOLON       reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    RBRACKET        reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    THEN            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    LOOP            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    OF              reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    COMMA           reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    IN              reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    ELSE            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    POOL            reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    FI              reduce using rule 68 (case -> CASE expression OF implications ESAC .)
    ESAC            reduce using rule 68 (case -> CASE expression OF implications ESAC .)


state 147

    (69) implications -> implication COMMA . implications
    (69) implications -> . implication COMMA implications
    (70) implications -> . implication
    (71) implication -> . id_type IMPLY expression
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    implication                    shift and go to state 140
    implications                   shift and go to state 150
    id_type                        shift and go to state 141

state 148

    (71) implication -> id_type IMPLY . expression
    (20) expression -> . assign
    (21) expression -> . upper_non
    (30) assign -> . ID ASSIGN expression
    (22) upper_non -> . NOT upper_non
    (23) upper_non -> . operator_non
    (24) operator_non -> . k_arith LTHAN k_arith
    (25) operator_non -> . k_arith LETHAN k_arith
    (26) operator_non -> . k_arith EQUALS k_arith
    (27) operator_non -> . k_arith
    (28) k_arith -> . arith
    (29) k_arith -> . e_arith
    (31) arith -> . arith PLUS term
    (32) arith -> . arith MINUS term
    (33) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (34) term -> . term TIMES factor
    (35) term -> . term DIVIDE factor
    (36) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (37) factor -> . MINUS factor
    (38) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (39) atom -> . LBRACKET expression RBRACKET
    (40) atom -> . INTEGER
    (41) atom -> . STRING
    (42) atom -> . ID
    (43) atom -> . TRUE
    (44) atom -> . FALSE
    (45) atom -> . ISVOID expression
    (46) atom -> . block
    (47) atom -> . conditional
    (48) atom -> . loop
    (49) atom -> . case
    (50) atom -> . dispatch
    (51) atom -> . NEW TYPE
    (52) atom -> . BCOMPLEMENT expression
    (61) let_expression -> . LET declaration_list IN expression
    (14) block -> . LBRACE expression_list RBRACE
    (66) conditional -> . IF expression THEN expression ELSE expression FI
    (67) loop -> . WHILE expression LOOP expression POOL
    (68) case -> . CASE expression OF implications ESAC
    (72) dispatch -> . expression especific DOT dispatch_call
    (73) dispatch -> . dispatch_call
    (76) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    INTEGER         shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    ISVOID          shift and go to state 51
    NEW             shift and go to state 57
    BCOMPLEMENT     shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 151
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 52
    conditional                    shift and go to state 53
    loop                           shift and go to state 54
    case                           shift and go to state 55
    dispatch                       shift and go to state 56
    dispatch_call                  shift and go to state 64

state 149

    (66) conditional -> IF expression THEN expression ELSE expression . FI
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    FI              shift and go to state 152
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 150

    (69) implications -> implication COMMA implications .

    ESAC            reduce using rule 69 (implications -> implication COMMA implications .)


state 151

    (71) implication -> id_type IMPLY expression .
    (72) dispatch -> expression . especific DOT dispatch_call
    (74) especific -> . DISP TYPE
    (75) especific -> . empty
    (80) empty -> .

    COMMA           reduce using rule 71 (implication -> id_type IMPLY expression .)
    ESAC            reduce using rule 71 (implication -> id_type IMPLY expression .)
    DISP            shift and go to state 68
    DOT             reduce using rule 80 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 152

    (66) conditional -> IF expression THEN expression ELSE expression FI .

    TIMES           reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    DIVIDE          reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    PLUS            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    MINUS           reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    LTHAN           reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    LETHAN          reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    EQUALS          reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    DISP            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    DOT             reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    SEMICOLON       reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    RBRACKET        reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    THEN            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    LOOP            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    OF              reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    COMMA           reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    IN              reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    ELSE            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    POOL            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    FI              reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)
    ESAC            reduce using rule 66 (conditional -> IF expression THEN expression ELSE expression FI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LTHAN in state 36 resolved as shift
WARNING: shift/reduce conflict for LETHAN in state 36 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 39 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 39 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for DISP in state 133 resolved as shift
WARNING: reduce/reduce conflict in state 72 resolved using rule (expression -> upper_non)
WARNING: rejected rule (upper_non -> NOT upper_non) in state 72
WARNING: reduce/reduce conflict in state 82 resolved using rule (term -> factor)
WARNING: rejected rule (factor -> MINUS factor) in state 82
WARNING: reduce/reduce conflict in state 83 resolved using rule (e_term -> e_factor)
WARNING: rejected rule (e_factor -> MINUS e_factor) in state 83
WARNING: reduce/reduce conflict in state 87 resolved using rule (atom -> ISVOID expression)
WARNING: rejected rule (empty -> <empty>) in state 87
WARNING: reduce/reduce conflict in state 89 resolved using rule (atom -> BCOMPLEMENT expression)
WARNING: rejected rule (empty -> <empty>) in state 89
WARNING: reduce/reduce conflict in state 102 resolved using rule (assign -> ID ASSIGN expression)
WARNING: rejected rule (empty -> <empty>) in state 102
WARNING: reduce/reduce conflict in state 106 resolved using rule (operator_non -> k_arith LTHAN k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 106
WARNING: reduce/reduce conflict in state 107 resolved using rule (operator_non -> k_arith LETHAN k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (operator_non -> k_arith EQUALS k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (arith -> arith PLUS term)
WARNING: rejected rule (arith -> term) in state 109
WARNING: reduce/reduce conflict in state 110 resolved using rule (e_arith -> arith PLUS e_term)
WARNING: rejected rule (e_arith -> e_term) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (arith -> arith MINUS term)
WARNING: rejected rule (arith -> term) in state 111
WARNING: reduce/reduce conflict in state 112 resolved using rule (e_arith -> arith MINUS e_term)
WARNING: rejected rule (e_arith -> e_term) in state 112
WARNING: reduce/reduce conflict in state 113 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 113
WARNING: reduce/reduce conflict in state 114 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 114
WARNING: reduce/reduce conflict in state 133 resolved using rule (let_expression -> LET declaration_list IN expression)
WARNING: rejected rule (empty -> <empty>) in state 133
