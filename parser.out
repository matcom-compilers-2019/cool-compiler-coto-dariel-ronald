Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> class SEMICOLON program
Rule 2     program -> class SEMICOLON
Rule 3     class -> CLASS TYPE inheritence LBRACE features RBRACE
Rule 4     inheritence -> INHERITS TYPE
Rule 5     inheritence -> empty
Rule 6     features -> feature SEMICOLON features
Rule 7     features -> empty
Rule 8     feature -> method_declaration
Rule 9     feature -> attribute
Rule 10    attribute -> id_type
Rule 11    attribute -> id_type ASSIGN expression
Rule 12    id_type -> ID TDOTS TYPE
Rule 13    method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE
Rule 14    formals -> id_type COMMA formals
Rule 15    formals -> id_type
Rule 16    formals -> empty
Rule 17    expression_list -> expression SEMICOLON expression_list
Rule 18    expression_list -> expression SEMICOLON
Rule 19    expression -> assign
Rule 20    expression -> upper_non
Rule 21    upper_non -> NOT upper_non
Rule 22    upper_non -> operator_non
Rule 23    operator_non -> k_arith LTHAN k_arith
Rule 24    operator_non -> k_arith LETHAN k_arith
Rule 25    operator_non -> k_arith EQUALS k_arith
Rule 26    operator_non -> k_arith
Rule 27    k_arith -> arith
Rule 28    k_arith -> e_arith
Rule 29    assign -> ID ASSIGN expression
Rule 30    arith -> arith PLUS term
Rule 31    arith -> arith MINUS term
Rule 32    arith -> term
Rule 33    term -> term TIMES factor
Rule 34    term -> term DIVIDE factor
Rule 35    term -> factor
Rule 36    factor -> MINUS factor
Rule 37    factor -> atom
Rule 38    atom -> LBRACKET expression RBRACKET
Rule 39    atom -> ISVOID expression
Rule 40    atom -> block
Rule 41    atom -> conditional
Rule 42    atom -> loop
Rule 43    atom -> case
Rule 44    atom -> dispatch
Rule 45    atom -> BCOMPLEMENT expression
Rule 46    block -> LBRACE expression_list RBRACE
Rule 47    atom -> ID
Rule 48    atom -> INTEGER
Rule 49    atom -> STRING
Rule 50    atom -> TRUE
Rule 51    atom -> FALSE
Rule 52    atom -> NEW TYPE
Rule 53    e_arith -> arith PLUS e_term
Rule 54    e_arith -> arith MINUS e_term
Rule 55    e_arith -> e_term
Rule 56    e_term -> e_term TIMES e_factor
Rule 57    e_term -> e_term DIVIDE e_factor
Rule 58    e_term -> e_factor
Rule 59    e_factor -> MINUS e_factor
Rule 60    e_factor -> let_expression
Rule 61    let_expression -> LET declaration_list IN expression
Rule 62    declaration_list -> attribute COMMA declaration_list
Rule 63    declaration_list -> attribute
Rule 64    conditional -> IF expression THEN expression ELSE expression FI
Rule 65    loop -> WHILE expression LOOP expression POOL
Rule 66    case -> CASE expression OF implications ESAC
Rule 67    implications -> implication SEMICOLON implications
Rule 68    implications -> implication SEMICOLON
Rule 69    implication -> id_type IMPLY expression
Rule 70    dispatch -> expression especific DOT dispatch_call
Rule 71    dispatch -> dispatch_call
Rule 72    especific -> DISP TYPE
Rule 73    especific -> empty
Rule 74    dispatch_call -> ID LBRACKET params_expression RBRACKET
Rule 75    params_expression -> expression
Rule 76    params_expression -> expression COMMA params_expression
Rule 77    params_expression -> empty
Rule 78    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 11 29
BCOMPLEMENT          : 45
CASE                 : 66
CLASS                : 3
COMMA                : 14 62 76
DISP                 : 72
DIVIDE               : 34 57
DOT                  : 70
ELSE                 : 64
EQUALS               : 25
ESAC                 : 66
FALSE                : 51
FI                   : 64
ID                   : 12 13 29 47 74
IF                   : 64
IMPLY                : 69
IN                   : 61
INHERITS             : 4
INTEGER              : 48
ISVOID               : 39
LBRACE               : 3 13 46
LBRACKET             : 13 38 74
LET                  : 61
LETHAN               : 24
LOOP                 : 65
LTHAN                : 23
MINUS                : 31 36 54 59
NEW                  : 52
NOT                  : 21
OF                   : 66
PLUS                 : 30 53
POOL                 : 65
RBRACE               : 3 13 46
RBRACKET             : 13 38 74
SEMICOLON            : 1 2 6 17 18 67 68
STRING               : 49
TDOTS                : 12 13
THEN                 : 64
TIMES                : 33 56
TRUE                 : 50
TYPE                 : 3 4 12 13 52 72
WHILE                : 65
error                : 

Nonterminals, with rules where they appear

arith                : 27 30 31 53 54
assign               : 19
atom                 : 37
attribute            : 9 62 63
block                : 40
case                 : 43
class                : 1 2
conditional          : 41
declaration_list     : 61 62
dispatch             : 44
dispatch_call        : 70 71
e_arith              : 28
e_factor             : 56 57 58 59
e_term               : 53 54 55 56 57
empty                : 5 7 16 73 77
especific            : 70
expression           : 11 13 17 18 29 38 39 45 61 64 64 64 65 65 66 69 70 75 76
expression_list      : 17 46
factor               : 33 34 35 36
feature              : 6
features             : 3 6
formals              : 13 14
id_type              : 10 11 14 15 69
implication          : 67 68
implications         : 66 67
inheritence          : 3
k_arith              : 23 23 24 24 25 25 26
let_expression       : 60
loop                 : 42
method_declaration   : 8
operator_non         : 22
params_expression    : 74 76
program              : 1 0
term                 : 30 31 32 33 34
upper_non            : 20 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class SEMICOLON program
    (2) program -> . class SEMICOLON
    (3) class -> . CLASS TYPE inheritence LBRACE features RBRACE

    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> class . SEMICOLON program
    (2) program -> class . SEMICOLON

    SEMICOLON       shift and go to state 4


state 3

    (3) class -> CLASS . TYPE inheritence LBRACE features RBRACE

    TYPE            shift and go to state 5


state 4

    (1) program -> class SEMICOLON . program
    (2) program -> class SEMICOLON .
    (1) program -> . class SEMICOLON program
    (2) program -> . class SEMICOLON
    (3) class -> . CLASS TYPE inheritence LBRACE features RBRACE

    $end            reduce using rule 2 (program -> class SEMICOLON .)
    CLASS           shift and go to state 3

    class                          shift and go to state 2
    program                        shift and go to state 6

state 5

    (3) class -> CLASS TYPE . inheritence LBRACE features RBRACE
    (4) inheritence -> . INHERITS TYPE
    (5) inheritence -> . empty
    (78) empty -> .

    INHERITS        shift and go to state 8
    LBRACE          reduce using rule 78 (empty -> .)

    inheritence                    shift and go to state 7
    empty                          shift and go to state 9

state 6

    (1) program -> class SEMICOLON program .

    $end            reduce using rule 1 (program -> class SEMICOLON program .)


state 7

    (3) class -> CLASS TYPE inheritence . LBRACE features RBRACE

    LBRACE          shift and go to state 10


state 8

    (4) inheritence -> INHERITS . TYPE

    TYPE            shift and go to state 11


state 9

    (5) inheritence -> empty .

    LBRACE          reduce using rule 5 (inheritence -> empty .)


state 10

    (3) class -> CLASS TYPE inheritence LBRACE . features RBRACE
    (6) features -> . feature SEMICOLON features
    (7) features -> . empty
    (8) feature -> . method_declaration
    (9) feature -> . attribute
    (78) empty -> .
    (13) method_declaration -> . ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    RBRACE          reduce using rule 78 (empty -> .)
    ID              shift and go to state 17

    features                       shift and go to state 12
    feature                        shift and go to state 13
    empty                          shift and go to state 14
    method_declaration             shift and go to state 15
    attribute                      shift and go to state 16
    id_type                        shift and go to state 18

state 11

    (4) inheritence -> INHERITS TYPE .

    LBRACE          reduce using rule 4 (inheritence -> INHERITS TYPE .)


state 12

    (3) class -> CLASS TYPE inheritence LBRACE features . RBRACE

    RBRACE          shift and go to state 19


state 13

    (6) features -> feature . SEMICOLON features

    SEMICOLON       shift and go to state 20


state 14

    (7) features -> empty .

    RBRACE          reduce using rule 7 (features -> empty .)


state 15

    (8) feature -> method_declaration .

    SEMICOLON       reduce using rule 8 (feature -> method_declaration .)


state 16

    (9) feature -> attribute .

    SEMICOLON       reduce using rule 9 (feature -> attribute .)


state 17

    (13) method_declaration -> ID . LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE
    (12) id_type -> ID . TDOTS TYPE

    LBRACKET        shift and go to state 21
    TDOTS           shift and go to state 22


state 18

    (10) attribute -> id_type .
    (11) attribute -> id_type . ASSIGN expression

    SEMICOLON       reduce using rule 10 (attribute -> id_type .)
    COMMA           reduce using rule 10 (attribute -> id_type .)
    IN              reduce using rule 10 (attribute -> id_type .)
    ASSIGN          shift and go to state 23


state 19

    (3) class -> CLASS TYPE inheritence LBRACE features RBRACE .

    SEMICOLON       reduce using rule 3 (class -> CLASS TYPE inheritence LBRACE features RBRACE .)


state 20

    (6) features -> feature SEMICOLON . features
    (6) features -> . feature SEMICOLON features
    (7) features -> . empty
    (8) feature -> . method_declaration
    (9) feature -> . attribute
    (78) empty -> .
    (13) method_declaration -> . ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    RBRACE          reduce using rule 78 (empty -> .)
    ID              shift and go to state 17

    feature                        shift and go to state 13
    features                       shift and go to state 24
    empty                          shift and go to state 14
    method_declaration             shift and go to state 15
    attribute                      shift and go to state 16
    id_type                        shift and go to state 18

state 21

    (13) method_declaration -> ID LBRACKET . formals RBRACKET TDOTS TYPE LBRACE expression RBRACE
    (14) formals -> . id_type COMMA formals
    (15) formals -> . id_type
    (16) formals -> . empty
    (12) id_type -> . ID TDOTS TYPE
    (78) empty -> .

    ID              shift and go to state 25
    RBRACKET        reduce using rule 78 (empty -> .)

    formals                        shift and go to state 26
    id_type                        shift and go to state 27
    empty                          shift and go to state 28

state 22

    (12) id_type -> ID TDOTS . TYPE

    TYPE            shift and go to state 29


state 23

    (11) attribute -> id_type ASSIGN . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 30
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 24

    (6) features -> feature SEMICOLON features .

    RBRACE          reduce using rule 6 (features -> feature SEMICOLON features .)


state 25

    (12) id_type -> ID . TDOTS TYPE

    TDOTS           shift and go to state 22


state 26

    (13) method_declaration -> ID LBRACKET formals . RBRACKET TDOTS TYPE LBRACE expression RBRACE

    RBRACKET        shift and go to state 65


state 27

    (14) formals -> id_type . COMMA formals
    (15) formals -> id_type .

    COMMA           shift and go to state 66
    RBRACKET        reduce using rule 15 (formals -> id_type .)


state 28

    (16) formals -> empty .

    RBRACKET        reduce using rule 16 (formals -> empty .)


state 29

    (12) id_type -> ID TDOTS TYPE .

    ASSIGN          reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    SEMICOLON       reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    COMMA           reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    RBRACKET        reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    IN              reduce using rule 12 (id_type -> ID TDOTS TYPE .)
    IMPLY           reduce using rule 12 (id_type -> ID TDOTS TYPE .)


state 30

    (11) attribute -> id_type ASSIGN expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    SEMICOLON       reduce using rule 11 (attribute -> id_type ASSIGN expression .)
    COMMA           reduce using rule 11 (attribute -> id_type ASSIGN expression .)
    IN              reduce using rule 11 (attribute -> id_type ASSIGN expression .)
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 31

    (19) expression -> assign .

    DISP            reduce using rule 19 (expression -> assign .)
    DOT             reduce using rule 19 (expression -> assign .)
    SEMICOLON       reduce using rule 19 (expression -> assign .)
    COMMA           reduce using rule 19 (expression -> assign .)
    IN              reduce using rule 19 (expression -> assign .)
    RBRACKET        reduce using rule 19 (expression -> assign .)
    TIMES           reduce using rule 19 (expression -> assign .)
    DIVIDE          reduce using rule 19 (expression -> assign .)
    PLUS            reduce using rule 19 (expression -> assign .)
    MINUS           reduce using rule 19 (expression -> assign .)
    LTHAN           reduce using rule 19 (expression -> assign .)
    LETHAN          reduce using rule 19 (expression -> assign .)
    EQUALS          reduce using rule 19 (expression -> assign .)
    THEN            reduce using rule 19 (expression -> assign .)
    LOOP            reduce using rule 19 (expression -> assign .)
    OF              reduce using rule 19 (expression -> assign .)
    ELSE            reduce using rule 19 (expression -> assign .)
    POOL            reduce using rule 19 (expression -> assign .)
    RBRACE          reduce using rule 19 (expression -> assign .)
    FI              reduce using rule 19 (expression -> assign .)


state 32

    (20) expression -> upper_non .

    DISP            reduce using rule 20 (expression -> upper_non .)
    DOT             reduce using rule 20 (expression -> upper_non .)
    SEMICOLON       reduce using rule 20 (expression -> upper_non .)
    COMMA           reduce using rule 20 (expression -> upper_non .)
    IN              reduce using rule 20 (expression -> upper_non .)
    RBRACKET        reduce using rule 20 (expression -> upper_non .)
    TIMES           reduce using rule 20 (expression -> upper_non .)
    DIVIDE          reduce using rule 20 (expression -> upper_non .)
    PLUS            reduce using rule 20 (expression -> upper_non .)
    MINUS           reduce using rule 20 (expression -> upper_non .)
    LTHAN           reduce using rule 20 (expression -> upper_non .)
    LETHAN          reduce using rule 20 (expression -> upper_non .)
    EQUALS          reduce using rule 20 (expression -> upper_non .)
    THEN            reduce using rule 20 (expression -> upper_non .)
    LOOP            reduce using rule 20 (expression -> upper_non .)
    OF              reduce using rule 20 (expression -> upper_non .)
    ELSE            reduce using rule 20 (expression -> upper_non .)
    POOL            reduce using rule 20 (expression -> upper_non .)
    RBRACE          reduce using rule 20 (expression -> upper_non .)
    FI              reduce using rule 20 (expression -> upper_non .)


state 33

    (29) assign -> ID . ASSIGN expression
    (47) atom -> ID .
    (74) dispatch_call -> ID . LBRACKET params_expression RBRACKET

    ASSIGN          shift and go to state 70
    TIMES           reduce using rule 47 (atom -> ID .)
    DIVIDE          reduce using rule 47 (atom -> ID .)
    PLUS            reduce using rule 47 (atom -> ID .)
    MINUS           reduce using rule 47 (atom -> ID .)
    LTHAN           reduce using rule 47 (atom -> ID .)
    LETHAN          reduce using rule 47 (atom -> ID .)
    EQUALS          reduce using rule 47 (atom -> ID .)
    DISP            reduce using rule 47 (atom -> ID .)
    DOT             reduce using rule 47 (atom -> ID .)
    SEMICOLON       reduce using rule 47 (atom -> ID .)
    COMMA           reduce using rule 47 (atom -> ID .)
    IN              reduce using rule 47 (atom -> ID .)
    RBRACKET        reduce using rule 47 (atom -> ID .)
    THEN            reduce using rule 47 (atom -> ID .)
    LOOP            reduce using rule 47 (atom -> ID .)
    OF              reduce using rule 47 (atom -> ID .)
    ELSE            reduce using rule 47 (atom -> ID .)
    POOL            reduce using rule 47 (atom -> ID .)
    RBRACE          reduce using rule 47 (atom -> ID .)
    FI              reduce using rule 47 (atom -> ID .)
    LBRACKET        shift and go to state 71


state 34

    (21) upper_non -> NOT . upper_non
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression

    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    upper_non                      shift and go to state 72
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31

state 35

    (22) upper_non -> operator_non .

    DISP            reduce using rule 22 (upper_non -> operator_non .)
    DOT             reduce using rule 22 (upper_non -> operator_non .)
    SEMICOLON       reduce using rule 22 (upper_non -> operator_non .)
    COMMA           reduce using rule 22 (upper_non -> operator_non .)
    IN              reduce using rule 22 (upper_non -> operator_non .)
    RBRACKET        reduce using rule 22 (upper_non -> operator_non .)
    TIMES           reduce using rule 22 (upper_non -> operator_non .)
    DIVIDE          reduce using rule 22 (upper_non -> operator_non .)
    PLUS            reduce using rule 22 (upper_non -> operator_non .)
    MINUS           reduce using rule 22 (upper_non -> operator_non .)
    LTHAN           reduce using rule 22 (upper_non -> operator_non .)
    LETHAN          reduce using rule 22 (upper_non -> operator_non .)
    EQUALS          reduce using rule 22 (upper_non -> operator_non .)
    THEN            reduce using rule 22 (upper_non -> operator_non .)
    LOOP            reduce using rule 22 (upper_non -> operator_non .)
    OF              reduce using rule 22 (upper_non -> operator_non .)
    ELSE            reduce using rule 22 (upper_non -> operator_non .)
    POOL            reduce using rule 22 (upper_non -> operator_non .)
    RBRACE          reduce using rule 22 (upper_non -> operator_non .)
    FI              reduce using rule 22 (upper_non -> operator_non .)


state 36

    (23) operator_non -> k_arith . LTHAN k_arith
    (24) operator_non -> k_arith . LETHAN k_arith
    (25) operator_non -> k_arith . EQUALS k_arith
    (26) operator_non -> k_arith .

  ! shift/reduce conflict for LTHAN resolved as shift
  ! shift/reduce conflict for LETHAN resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
    LTHAN           shift and go to state 75
    LETHAN          shift and go to state 76
    EQUALS          shift and go to state 77
    DISP            reduce using rule 26 (operator_non -> k_arith .)
    DOT             reduce using rule 26 (operator_non -> k_arith .)
    SEMICOLON       reduce using rule 26 (operator_non -> k_arith .)
    COMMA           reduce using rule 26 (operator_non -> k_arith .)
    IN              reduce using rule 26 (operator_non -> k_arith .)
    RBRACKET        reduce using rule 26 (operator_non -> k_arith .)
    TIMES           reduce using rule 26 (operator_non -> k_arith .)
    DIVIDE          reduce using rule 26 (operator_non -> k_arith .)
    PLUS            reduce using rule 26 (operator_non -> k_arith .)
    MINUS           reduce using rule 26 (operator_non -> k_arith .)
    THEN            reduce using rule 26 (operator_non -> k_arith .)
    LOOP            reduce using rule 26 (operator_non -> k_arith .)
    OF              reduce using rule 26 (operator_non -> k_arith .)
    ELSE            reduce using rule 26 (operator_non -> k_arith .)
    POOL            reduce using rule 26 (operator_non -> k_arith .)
    RBRACE          reduce using rule 26 (operator_non -> k_arith .)
    FI              reduce using rule 26 (operator_non -> k_arith .)

  ! LTHAN           [ reduce using rule 26 (operator_non -> k_arith .) ]
  ! LETHAN          [ reduce using rule 26 (operator_non -> k_arith .) ]
  ! EQUALS          [ reduce using rule 26 (operator_non -> k_arith .) ]


state 37

    (27) k_arith -> arith .
    (30) arith -> arith . PLUS term
    (31) arith -> arith . MINUS term
    (53) e_arith -> arith . PLUS e_term
    (54) e_arith -> arith . MINUS e_term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LTHAN           reduce using rule 27 (k_arith -> arith .)
    LETHAN          reduce using rule 27 (k_arith -> arith .)
    EQUALS          reduce using rule 27 (k_arith -> arith .)
    DISP            reduce using rule 27 (k_arith -> arith .)
    DOT             reduce using rule 27 (k_arith -> arith .)
    SEMICOLON       reduce using rule 27 (k_arith -> arith .)
    COMMA           reduce using rule 27 (k_arith -> arith .)
    IN              reduce using rule 27 (k_arith -> arith .)
    RBRACKET        reduce using rule 27 (k_arith -> arith .)
    TIMES           reduce using rule 27 (k_arith -> arith .)
    DIVIDE          reduce using rule 27 (k_arith -> arith .)
    THEN            reduce using rule 27 (k_arith -> arith .)
    LOOP            reduce using rule 27 (k_arith -> arith .)
    OF              reduce using rule 27 (k_arith -> arith .)
    ELSE            reduce using rule 27 (k_arith -> arith .)
    POOL            reduce using rule 27 (k_arith -> arith .)
    RBRACE          reduce using rule 27 (k_arith -> arith .)
    FI              reduce using rule 27 (k_arith -> arith .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79

  ! PLUS            [ reduce using rule 27 (k_arith -> arith .) ]
  ! MINUS           [ reduce using rule 27 (k_arith -> arith .) ]


state 38

    (28) k_arith -> e_arith .

    LTHAN           reduce using rule 28 (k_arith -> e_arith .)
    LETHAN          reduce using rule 28 (k_arith -> e_arith .)
    EQUALS          reduce using rule 28 (k_arith -> e_arith .)
    DISP            reduce using rule 28 (k_arith -> e_arith .)
    DOT             reduce using rule 28 (k_arith -> e_arith .)
    SEMICOLON       reduce using rule 28 (k_arith -> e_arith .)
    COMMA           reduce using rule 28 (k_arith -> e_arith .)
    IN              reduce using rule 28 (k_arith -> e_arith .)
    RBRACKET        reduce using rule 28 (k_arith -> e_arith .)
    TIMES           reduce using rule 28 (k_arith -> e_arith .)
    DIVIDE          reduce using rule 28 (k_arith -> e_arith .)
    PLUS            reduce using rule 28 (k_arith -> e_arith .)
    MINUS           reduce using rule 28 (k_arith -> e_arith .)
    THEN            reduce using rule 28 (k_arith -> e_arith .)
    LOOP            reduce using rule 28 (k_arith -> e_arith .)
    OF              reduce using rule 28 (k_arith -> e_arith .)
    ELSE            reduce using rule 28 (k_arith -> e_arith .)
    POOL            reduce using rule 28 (k_arith -> e_arith .)
    RBRACE          reduce using rule 28 (k_arith -> e_arith .)
    FI              reduce using rule 28 (k_arith -> e_arith .)


state 39

    (32) arith -> term .
    (33) term -> term . TIMES factor
    (34) term -> term . DIVIDE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 32 (arith -> term .)
    MINUS           reduce using rule 32 (arith -> term .)
    LTHAN           reduce using rule 32 (arith -> term .)
    LETHAN          reduce using rule 32 (arith -> term .)
    EQUALS          reduce using rule 32 (arith -> term .)
    DISP            reduce using rule 32 (arith -> term .)
    DOT             reduce using rule 32 (arith -> term .)
    SEMICOLON       reduce using rule 32 (arith -> term .)
    COMMA           reduce using rule 32 (arith -> term .)
    IN              reduce using rule 32 (arith -> term .)
    RBRACKET        reduce using rule 32 (arith -> term .)
    THEN            reduce using rule 32 (arith -> term .)
    LOOP            reduce using rule 32 (arith -> term .)
    OF              reduce using rule 32 (arith -> term .)
    ELSE            reduce using rule 32 (arith -> term .)
    POOL            reduce using rule 32 (arith -> term .)
    RBRACE          reduce using rule 32 (arith -> term .)
    FI              reduce using rule 32 (arith -> term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 32 (arith -> term .) ]
  ! DIVIDE          [ reduce using rule 32 (arith -> term .) ]


state 40

    (36) factor -> MINUS . factor
    (59) e_factor -> MINUS . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    factor                         shift and go to state 82
    e_factor                       shift and go to state 83
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41

state 41

    (55) e_arith -> e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    LTHAN           reduce using rule 55 (e_arith -> e_term .)
    LETHAN          reduce using rule 55 (e_arith -> e_term .)
    EQUALS          reduce using rule 55 (e_arith -> e_term .)
    DISP            reduce using rule 55 (e_arith -> e_term .)
    DOT             reduce using rule 55 (e_arith -> e_term .)
    SEMICOLON       reduce using rule 55 (e_arith -> e_term .)
    COMMA           reduce using rule 55 (e_arith -> e_term .)
    IN              reduce using rule 55 (e_arith -> e_term .)
    RBRACKET        reduce using rule 55 (e_arith -> e_term .)
    PLUS            reduce using rule 55 (e_arith -> e_term .)
    MINUS           reduce using rule 55 (e_arith -> e_term .)
    THEN            reduce using rule 55 (e_arith -> e_term .)
    LOOP            reduce using rule 55 (e_arith -> e_term .)
    OF              reduce using rule 55 (e_arith -> e_term .)
    ELSE            reduce using rule 55 (e_arith -> e_term .)
    POOL            reduce using rule 55 (e_arith -> e_term .)
    RBRACE          reduce using rule 55 (e_arith -> e_term .)
    FI              reduce using rule 55 (e_arith -> e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DIVIDE          [ reduce using rule 55 (e_arith -> e_term .) ]


state 42

    (35) term -> factor .

    TIMES           reduce using rule 35 (term -> factor .)
    DIVIDE          reduce using rule 35 (term -> factor .)
    PLUS            reduce using rule 35 (term -> factor .)
    MINUS           reduce using rule 35 (term -> factor .)
    LTHAN           reduce using rule 35 (term -> factor .)
    LETHAN          reduce using rule 35 (term -> factor .)
    EQUALS          reduce using rule 35 (term -> factor .)
    DISP            reduce using rule 35 (term -> factor .)
    DOT             reduce using rule 35 (term -> factor .)
    SEMICOLON       reduce using rule 35 (term -> factor .)
    COMMA           reduce using rule 35 (term -> factor .)
    IN              reduce using rule 35 (term -> factor .)
    RBRACKET        reduce using rule 35 (term -> factor .)
    THEN            reduce using rule 35 (term -> factor .)
    LOOP            reduce using rule 35 (term -> factor .)
    OF              reduce using rule 35 (term -> factor .)
    ELSE            reduce using rule 35 (term -> factor .)
    POOL            reduce using rule 35 (term -> factor .)
    RBRACE          reduce using rule 35 (term -> factor .)
    FI              reduce using rule 35 (term -> factor .)


state 43

    (58) e_term -> e_factor .

    TIMES           reduce using rule 58 (e_term -> e_factor .)
    DIVIDE          reduce using rule 58 (e_term -> e_factor .)
    LTHAN           reduce using rule 58 (e_term -> e_factor .)
    LETHAN          reduce using rule 58 (e_term -> e_factor .)
    EQUALS          reduce using rule 58 (e_term -> e_factor .)
    DISP            reduce using rule 58 (e_term -> e_factor .)
    DOT             reduce using rule 58 (e_term -> e_factor .)
    SEMICOLON       reduce using rule 58 (e_term -> e_factor .)
    COMMA           reduce using rule 58 (e_term -> e_factor .)
    IN              reduce using rule 58 (e_term -> e_factor .)
    RBRACKET        reduce using rule 58 (e_term -> e_factor .)
    PLUS            reduce using rule 58 (e_term -> e_factor .)
    MINUS           reduce using rule 58 (e_term -> e_factor .)
    THEN            reduce using rule 58 (e_term -> e_factor .)
    LOOP            reduce using rule 58 (e_term -> e_factor .)
    OF              reduce using rule 58 (e_term -> e_factor .)
    ELSE            reduce using rule 58 (e_term -> e_factor .)
    POOL            reduce using rule 58 (e_term -> e_factor .)
    RBRACE          reduce using rule 58 (e_term -> e_factor .)
    FI              reduce using rule 58 (e_term -> e_factor .)


state 44

    (37) factor -> atom .

    TIMES           reduce using rule 37 (factor -> atom .)
    DIVIDE          reduce using rule 37 (factor -> atom .)
    PLUS            reduce using rule 37 (factor -> atom .)
    MINUS           reduce using rule 37 (factor -> atom .)
    LTHAN           reduce using rule 37 (factor -> atom .)
    LETHAN          reduce using rule 37 (factor -> atom .)
    EQUALS          reduce using rule 37 (factor -> atom .)
    DISP            reduce using rule 37 (factor -> atom .)
    DOT             reduce using rule 37 (factor -> atom .)
    SEMICOLON       reduce using rule 37 (factor -> atom .)
    COMMA           reduce using rule 37 (factor -> atom .)
    IN              reduce using rule 37 (factor -> atom .)
    RBRACKET        reduce using rule 37 (factor -> atom .)
    THEN            reduce using rule 37 (factor -> atom .)
    LOOP            reduce using rule 37 (factor -> atom .)
    OF              reduce using rule 37 (factor -> atom .)
    ELSE            reduce using rule 37 (factor -> atom .)
    POOL            reduce using rule 37 (factor -> atom .)
    RBRACE          reduce using rule 37 (factor -> atom .)
    FI              reduce using rule 37 (factor -> atom .)


state 45

    (60) e_factor -> let_expression .

    TIMES           reduce using rule 60 (e_factor -> let_expression .)
    DIVIDE          reduce using rule 60 (e_factor -> let_expression .)
    LTHAN           reduce using rule 60 (e_factor -> let_expression .)
    LETHAN          reduce using rule 60 (e_factor -> let_expression .)
    EQUALS          reduce using rule 60 (e_factor -> let_expression .)
    DISP            reduce using rule 60 (e_factor -> let_expression .)
    DOT             reduce using rule 60 (e_factor -> let_expression .)
    SEMICOLON       reduce using rule 60 (e_factor -> let_expression .)
    COMMA           reduce using rule 60 (e_factor -> let_expression .)
    IN              reduce using rule 60 (e_factor -> let_expression .)
    RBRACKET        reduce using rule 60 (e_factor -> let_expression .)
    PLUS            reduce using rule 60 (e_factor -> let_expression .)
    MINUS           reduce using rule 60 (e_factor -> let_expression .)
    THEN            reduce using rule 60 (e_factor -> let_expression .)
    LOOP            reduce using rule 60 (e_factor -> let_expression .)
    OF              reduce using rule 60 (e_factor -> let_expression .)
    ELSE            reduce using rule 60 (e_factor -> let_expression .)
    POOL            reduce using rule 60 (e_factor -> let_expression .)
    RBRACE          reduce using rule 60 (e_factor -> let_expression .)
    FI              reduce using rule 60 (e_factor -> let_expression .)


state 46

    (38) atom -> LBRACKET . expression RBRACKET
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 86
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 47

    (39) atom -> ISVOID . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 87
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 48

    (40) atom -> block .

    TIMES           reduce using rule 40 (atom -> block .)
    DIVIDE          reduce using rule 40 (atom -> block .)
    PLUS            reduce using rule 40 (atom -> block .)
    MINUS           reduce using rule 40 (atom -> block .)
    LTHAN           reduce using rule 40 (atom -> block .)
    LETHAN          reduce using rule 40 (atom -> block .)
    EQUALS          reduce using rule 40 (atom -> block .)
    DISP            reduce using rule 40 (atom -> block .)
    DOT             reduce using rule 40 (atom -> block .)
    SEMICOLON       reduce using rule 40 (atom -> block .)
    COMMA           reduce using rule 40 (atom -> block .)
    IN              reduce using rule 40 (atom -> block .)
    RBRACKET        reduce using rule 40 (atom -> block .)
    THEN            reduce using rule 40 (atom -> block .)
    LOOP            reduce using rule 40 (atom -> block .)
    OF              reduce using rule 40 (atom -> block .)
    ELSE            reduce using rule 40 (atom -> block .)
    POOL            reduce using rule 40 (atom -> block .)
    RBRACE          reduce using rule 40 (atom -> block .)
    FI              reduce using rule 40 (atom -> block .)


state 49

    (41) atom -> conditional .

    TIMES           reduce using rule 41 (atom -> conditional .)
    DIVIDE          reduce using rule 41 (atom -> conditional .)
    PLUS            reduce using rule 41 (atom -> conditional .)
    MINUS           reduce using rule 41 (atom -> conditional .)
    LTHAN           reduce using rule 41 (atom -> conditional .)
    LETHAN          reduce using rule 41 (atom -> conditional .)
    EQUALS          reduce using rule 41 (atom -> conditional .)
    DISP            reduce using rule 41 (atom -> conditional .)
    DOT             reduce using rule 41 (atom -> conditional .)
    SEMICOLON       reduce using rule 41 (atom -> conditional .)
    COMMA           reduce using rule 41 (atom -> conditional .)
    IN              reduce using rule 41 (atom -> conditional .)
    RBRACKET        reduce using rule 41 (atom -> conditional .)
    THEN            reduce using rule 41 (atom -> conditional .)
    LOOP            reduce using rule 41 (atom -> conditional .)
    OF              reduce using rule 41 (atom -> conditional .)
    ELSE            reduce using rule 41 (atom -> conditional .)
    POOL            reduce using rule 41 (atom -> conditional .)
    RBRACE          reduce using rule 41 (atom -> conditional .)
    FI              reduce using rule 41 (atom -> conditional .)


state 50

    (42) atom -> loop .

    TIMES           reduce using rule 42 (atom -> loop .)
    DIVIDE          reduce using rule 42 (atom -> loop .)
    PLUS            reduce using rule 42 (atom -> loop .)
    MINUS           reduce using rule 42 (atom -> loop .)
    LTHAN           reduce using rule 42 (atom -> loop .)
    LETHAN          reduce using rule 42 (atom -> loop .)
    EQUALS          reduce using rule 42 (atom -> loop .)
    DISP            reduce using rule 42 (atom -> loop .)
    DOT             reduce using rule 42 (atom -> loop .)
    SEMICOLON       reduce using rule 42 (atom -> loop .)
    COMMA           reduce using rule 42 (atom -> loop .)
    IN              reduce using rule 42 (atom -> loop .)
    RBRACKET        reduce using rule 42 (atom -> loop .)
    THEN            reduce using rule 42 (atom -> loop .)
    LOOP            reduce using rule 42 (atom -> loop .)
    OF              reduce using rule 42 (atom -> loop .)
    ELSE            reduce using rule 42 (atom -> loop .)
    POOL            reduce using rule 42 (atom -> loop .)
    RBRACE          reduce using rule 42 (atom -> loop .)
    FI              reduce using rule 42 (atom -> loop .)


state 51

    (43) atom -> case .

    TIMES           reduce using rule 43 (atom -> case .)
    DIVIDE          reduce using rule 43 (atom -> case .)
    PLUS            reduce using rule 43 (atom -> case .)
    MINUS           reduce using rule 43 (atom -> case .)
    LTHAN           reduce using rule 43 (atom -> case .)
    LETHAN          reduce using rule 43 (atom -> case .)
    EQUALS          reduce using rule 43 (atom -> case .)
    DISP            reduce using rule 43 (atom -> case .)
    DOT             reduce using rule 43 (atom -> case .)
    SEMICOLON       reduce using rule 43 (atom -> case .)
    COMMA           reduce using rule 43 (atom -> case .)
    IN              reduce using rule 43 (atom -> case .)
    RBRACKET        reduce using rule 43 (atom -> case .)
    THEN            reduce using rule 43 (atom -> case .)
    LOOP            reduce using rule 43 (atom -> case .)
    OF              reduce using rule 43 (atom -> case .)
    ELSE            reduce using rule 43 (atom -> case .)
    POOL            reduce using rule 43 (atom -> case .)
    RBRACE          reduce using rule 43 (atom -> case .)
    FI              reduce using rule 43 (atom -> case .)


state 52

    (44) atom -> dispatch .

    TIMES           reduce using rule 44 (atom -> dispatch .)
    DIVIDE          reduce using rule 44 (atom -> dispatch .)
    PLUS            reduce using rule 44 (atom -> dispatch .)
    MINUS           reduce using rule 44 (atom -> dispatch .)
    LTHAN           reduce using rule 44 (atom -> dispatch .)
    LETHAN          reduce using rule 44 (atom -> dispatch .)
    EQUALS          reduce using rule 44 (atom -> dispatch .)
    DISP            reduce using rule 44 (atom -> dispatch .)
    DOT             reduce using rule 44 (atom -> dispatch .)
    SEMICOLON       reduce using rule 44 (atom -> dispatch .)
    COMMA           reduce using rule 44 (atom -> dispatch .)
    IN              reduce using rule 44 (atom -> dispatch .)
    RBRACKET        reduce using rule 44 (atom -> dispatch .)
    THEN            reduce using rule 44 (atom -> dispatch .)
    LOOP            reduce using rule 44 (atom -> dispatch .)
    OF              reduce using rule 44 (atom -> dispatch .)
    ELSE            reduce using rule 44 (atom -> dispatch .)
    POOL            reduce using rule 44 (atom -> dispatch .)
    RBRACE          reduce using rule 44 (atom -> dispatch .)
    FI              reduce using rule 44 (atom -> dispatch .)


state 53

    (45) atom -> BCOMPLEMENT . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 88
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 54

    (48) atom -> INTEGER .

    TIMES           reduce using rule 48 (atom -> INTEGER .)
    DIVIDE          reduce using rule 48 (atom -> INTEGER .)
    PLUS            reduce using rule 48 (atom -> INTEGER .)
    MINUS           reduce using rule 48 (atom -> INTEGER .)
    LTHAN           reduce using rule 48 (atom -> INTEGER .)
    LETHAN          reduce using rule 48 (atom -> INTEGER .)
    EQUALS          reduce using rule 48 (atom -> INTEGER .)
    DISP            reduce using rule 48 (atom -> INTEGER .)
    DOT             reduce using rule 48 (atom -> INTEGER .)
    SEMICOLON       reduce using rule 48 (atom -> INTEGER .)
    COMMA           reduce using rule 48 (atom -> INTEGER .)
    IN              reduce using rule 48 (atom -> INTEGER .)
    RBRACKET        reduce using rule 48 (atom -> INTEGER .)
    THEN            reduce using rule 48 (atom -> INTEGER .)
    LOOP            reduce using rule 48 (atom -> INTEGER .)
    OF              reduce using rule 48 (atom -> INTEGER .)
    ELSE            reduce using rule 48 (atom -> INTEGER .)
    POOL            reduce using rule 48 (atom -> INTEGER .)
    RBRACE          reduce using rule 48 (atom -> INTEGER .)
    FI              reduce using rule 48 (atom -> INTEGER .)


state 55

    (49) atom -> STRING .

    TIMES           reduce using rule 49 (atom -> STRING .)
    DIVIDE          reduce using rule 49 (atom -> STRING .)
    PLUS            reduce using rule 49 (atom -> STRING .)
    MINUS           reduce using rule 49 (atom -> STRING .)
    LTHAN           reduce using rule 49 (atom -> STRING .)
    LETHAN          reduce using rule 49 (atom -> STRING .)
    EQUALS          reduce using rule 49 (atom -> STRING .)
    DISP            reduce using rule 49 (atom -> STRING .)
    DOT             reduce using rule 49 (atom -> STRING .)
    SEMICOLON       reduce using rule 49 (atom -> STRING .)
    COMMA           reduce using rule 49 (atom -> STRING .)
    IN              reduce using rule 49 (atom -> STRING .)
    RBRACKET        reduce using rule 49 (atom -> STRING .)
    THEN            reduce using rule 49 (atom -> STRING .)
    LOOP            reduce using rule 49 (atom -> STRING .)
    OF              reduce using rule 49 (atom -> STRING .)
    ELSE            reduce using rule 49 (atom -> STRING .)
    POOL            reduce using rule 49 (atom -> STRING .)
    RBRACE          reduce using rule 49 (atom -> STRING .)
    FI              reduce using rule 49 (atom -> STRING .)


state 56

    (50) atom -> TRUE .

    TIMES           reduce using rule 50 (atom -> TRUE .)
    DIVIDE          reduce using rule 50 (atom -> TRUE .)
    PLUS            reduce using rule 50 (atom -> TRUE .)
    MINUS           reduce using rule 50 (atom -> TRUE .)
    LTHAN           reduce using rule 50 (atom -> TRUE .)
    LETHAN          reduce using rule 50 (atom -> TRUE .)
    EQUALS          reduce using rule 50 (atom -> TRUE .)
    DISP            reduce using rule 50 (atom -> TRUE .)
    DOT             reduce using rule 50 (atom -> TRUE .)
    SEMICOLON       reduce using rule 50 (atom -> TRUE .)
    COMMA           reduce using rule 50 (atom -> TRUE .)
    IN              reduce using rule 50 (atom -> TRUE .)
    RBRACKET        reduce using rule 50 (atom -> TRUE .)
    THEN            reduce using rule 50 (atom -> TRUE .)
    LOOP            reduce using rule 50 (atom -> TRUE .)
    OF              reduce using rule 50 (atom -> TRUE .)
    ELSE            reduce using rule 50 (atom -> TRUE .)
    POOL            reduce using rule 50 (atom -> TRUE .)
    RBRACE          reduce using rule 50 (atom -> TRUE .)
    FI              reduce using rule 50 (atom -> TRUE .)


state 57

    (51) atom -> FALSE .

    TIMES           reduce using rule 51 (atom -> FALSE .)
    DIVIDE          reduce using rule 51 (atom -> FALSE .)
    PLUS            reduce using rule 51 (atom -> FALSE .)
    MINUS           reduce using rule 51 (atom -> FALSE .)
    LTHAN           reduce using rule 51 (atom -> FALSE .)
    LETHAN          reduce using rule 51 (atom -> FALSE .)
    EQUALS          reduce using rule 51 (atom -> FALSE .)
    DISP            reduce using rule 51 (atom -> FALSE .)
    DOT             reduce using rule 51 (atom -> FALSE .)
    SEMICOLON       reduce using rule 51 (atom -> FALSE .)
    COMMA           reduce using rule 51 (atom -> FALSE .)
    IN              reduce using rule 51 (atom -> FALSE .)
    RBRACKET        reduce using rule 51 (atom -> FALSE .)
    THEN            reduce using rule 51 (atom -> FALSE .)
    LOOP            reduce using rule 51 (atom -> FALSE .)
    OF              reduce using rule 51 (atom -> FALSE .)
    ELSE            reduce using rule 51 (atom -> FALSE .)
    POOL            reduce using rule 51 (atom -> FALSE .)
    RBRACE          reduce using rule 51 (atom -> FALSE .)
    FI              reduce using rule 51 (atom -> FALSE .)


state 58

    (52) atom -> NEW . TYPE

    TYPE            shift and go to state 89


state 59

    (61) let_expression -> LET . declaration_list IN expression
    (62) declaration_list -> . attribute COMMA declaration_list
    (63) declaration_list -> . attribute
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    declaration_list               shift and go to state 90
    attribute                      shift and go to state 91
    id_type                        shift and go to state 18

state 60

    (46) block -> LBRACE . expression_list RBRACE
    (17) expression_list -> . expression SEMICOLON expression_list
    (18) expression_list -> . expression SEMICOLON
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression_list                shift and go to state 92
    expression                     shift and go to state 93
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 61

    (64) conditional -> IF . expression THEN expression ELSE expression FI
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 94
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 62

    (65) loop -> WHILE . expression LOOP expression POOL
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 95
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 63

    (66) case -> CASE . expression OF implications ESAC
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 96
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 64

    (71) dispatch -> dispatch_call .

    TIMES           reduce using rule 71 (dispatch -> dispatch_call .)
    DIVIDE          reduce using rule 71 (dispatch -> dispatch_call .)
    PLUS            reduce using rule 71 (dispatch -> dispatch_call .)
    MINUS           reduce using rule 71 (dispatch -> dispatch_call .)
    LTHAN           reduce using rule 71 (dispatch -> dispatch_call .)
    LETHAN          reduce using rule 71 (dispatch -> dispatch_call .)
    EQUALS          reduce using rule 71 (dispatch -> dispatch_call .)
    DISP            reduce using rule 71 (dispatch -> dispatch_call .)
    DOT             reduce using rule 71 (dispatch -> dispatch_call .)
    SEMICOLON       reduce using rule 71 (dispatch -> dispatch_call .)
    COMMA           reduce using rule 71 (dispatch -> dispatch_call .)
    IN              reduce using rule 71 (dispatch -> dispatch_call .)
    RBRACKET        reduce using rule 71 (dispatch -> dispatch_call .)
    THEN            reduce using rule 71 (dispatch -> dispatch_call .)
    LOOP            reduce using rule 71 (dispatch -> dispatch_call .)
    OF              reduce using rule 71 (dispatch -> dispatch_call .)
    ELSE            reduce using rule 71 (dispatch -> dispatch_call .)
    POOL            reduce using rule 71 (dispatch -> dispatch_call .)
    RBRACE          reduce using rule 71 (dispatch -> dispatch_call .)
    FI              reduce using rule 71 (dispatch -> dispatch_call .)


state 65

    (13) method_declaration -> ID LBRACKET formals RBRACKET . TDOTS TYPE LBRACE expression RBRACE

    TDOTS           shift and go to state 97


state 66

    (14) formals -> id_type COMMA . formals
    (14) formals -> . id_type COMMA formals
    (15) formals -> . id_type
    (16) formals -> . empty
    (12) id_type -> . ID TDOTS TYPE
    (78) empty -> .

    ID              shift and go to state 25
    RBRACKET        reduce using rule 78 (empty -> .)

    id_type                        shift and go to state 27
    formals                        shift and go to state 98
    empty                          shift and go to state 28

state 67

    (70) dispatch -> expression especific . DOT dispatch_call

    DOT             shift and go to state 99


state 68

    (72) especific -> DISP . TYPE

    TYPE            shift and go to state 100


state 69

    (73) especific -> empty .

    DOT             reduce using rule 73 (especific -> empty .)


state 70

    (29) assign -> ID ASSIGN . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 101
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 71

    (74) dispatch_call -> ID LBRACKET . params_expression RBRACKET
    (75) params_expression -> . expression
    (76) params_expression -> . expression COMMA params_expression
    (77) params_expression -> . empty
    (19) expression -> . assign
    (20) expression -> . upper_non
    (78) empty -> .
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACKET        reduce using rule 78 (empty -> .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    params_expression              shift and go to state 102
    expression                     shift and go to state 103
    empty                          shift and go to state 104
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 72

    (21) upper_non -> NOT upper_non .
    (20) expression -> upper_non .

  ! reduce/reduce conflict for DISP resolved using rule 20 (expression -> upper_non .)
  ! reduce/reduce conflict for DOT resolved using rule 20 (expression -> upper_non .)
    SEMICOLON       reduce using rule 21 (upper_non -> NOT upper_non .)
    COMMA           reduce using rule 21 (upper_non -> NOT upper_non .)
    IN              reduce using rule 21 (upper_non -> NOT upper_non .)
    RBRACKET        reduce using rule 21 (upper_non -> NOT upper_non .)
    TIMES           reduce using rule 21 (upper_non -> NOT upper_non .)
    DIVIDE          reduce using rule 21 (upper_non -> NOT upper_non .)
    PLUS            reduce using rule 21 (upper_non -> NOT upper_non .)
    MINUS           reduce using rule 21 (upper_non -> NOT upper_non .)
    LTHAN           reduce using rule 21 (upper_non -> NOT upper_non .)
    LETHAN          reduce using rule 21 (upper_non -> NOT upper_non .)
    EQUALS          reduce using rule 21 (upper_non -> NOT upper_non .)
    THEN            reduce using rule 21 (upper_non -> NOT upper_non .)
    LOOP            reduce using rule 21 (upper_non -> NOT upper_non .)
    OF              reduce using rule 21 (upper_non -> NOT upper_non .)
    ELSE            reduce using rule 21 (upper_non -> NOT upper_non .)
    POOL            reduce using rule 21 (upper_non -> NOT upper_non .)
    RBRACE          reduce using rule 21 (upper_non -> NOT upper_non .)
    FI              reduce using rule 21 (upper_non -> NOT upper_non .)
    DISP            reduce using rule 20 (expression -> upper_non .)
    DOT             reduce using rule 20 (expression -> upper_non .)

  ! DISP            [ reduce using rule 21 (upper_non -> NOT upper_non .) ]
  ! DOT             [ reduce using rule 21 (upper_non -> NOT upper_non .) ]


state 73

    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 74

    (47) atom -> ID .
    (74) dispatch_call -> ID . LBRACKET params_expression RBRACKET
    (29) assign -> ID . ASSIGN expression

    DISP            reduce using rule 47 (atom -> ID .)
    DOT             reduce using rule 47 (atom -> ID .)
    SEMICOLON       reduce using rule 47 (atom -> ID .)
    COMMA           reduce using rule 47 (atom -> ID .)
    IN              reduce using rule 47 (atom -> ID .)
    RBRACKET        reduce using rule 47 (atom -> ID .)
    TIMES           reduce using rule 47 (atom -> ID .)
    DIVIDE          reduce using rule 47 (atom -> ID .)
    PLUS            reduce using rule 47 (atom -> ID .)
    MINUS           reduce using rule 47 (atom -> ID .)
    LTHAN           reduce using rule 47 (atom -> ID .)
    LETHAN          reduce using rule 47 (atom -> ID .)
    EQUALS          reduce using rule 47 (atom -> ID .)
    THEN            reduce using rule 47 (atom -> ID .)
    LOOP            reduce using rule 47 (atom -> ID .)
    OF              reduce using rule 47 (atom -> ID .)
    ELSE            reduce using rule 47 (atom -> ID .)
    POOL            reduce using rule 47 (atom -> ID .)
    RBRACE          reduce using rule 47 (atom -> ID .)
    FI              reduce using rule 47 (atom -> ID .)
    LBRACKET        shift and go to state 71
    ASSIGN          shift and go to state 70


state 75

    (23) operator_non -> k_arith LTHAN . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 105
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 76

    (24) operator_non -> k_arith LETHAN . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 106
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 77

    (25) operator_non -> k_arith EQUALS . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    k_arith                        shift and go to state 107
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35

state 78

    (30) arith -> arith PLUS . term
    (53) e_arith -> arith PLUS . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    arith                          shift and go to state 37
    term                           shift and go to state 108
    e_term                         shift and go to state 109
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    e_arith                        shift and go to state 38

state 79

    (31) arith -> arith MINUS . term
    (54) e_arith -> arith MINUS . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34

    arith                          shift and go to state 37
    term                           shift and go to state 110
    e_term                         shift and go to state 111
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    e_arith                        shift and go to state 38

state 80

    (33) term -> term TIMES . factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34
    LET             shift and go to state 59

    term                           shift and go to state 39
    factor                         shift and go to state 112
    atom                           shift and go to state 44
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    e_term                         shift and go to state 41
    e_factor                       shift and go to state 43
    let_expression                 shift and go to state 45

state 81

    (34) term -> term DIVIDE . factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (19) expression -> . assign
    (20) expression -> . upper_non
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    ID              shift and go to state 74
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63
    NOT             shift and go to state 34
    LET             shift and go to state 59

    term                           shift and go to state 39
    factor                         shift and go to state 113
    atom                           shift and go to state 44
    expression                     shift and go to state 73
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    e_term                         shift and go to state 41
    e_factor                       shift and go to state 43
    let_expression                 shift and go to state 45

state 82

    (36) factor -> MINUS factor .
    (35) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for DISP resolved using rule 35 (term -> factor .)
  ! reduce/reduce conflict for DOT resolved using rule 35 (term -> factor .)
    SEMICOLON       reduce using rule 36 (factor -> MINUS factor .)
    COMMA           reduce using rule 36 (factor -> MINUS factor .)
    IN              reduce using rule 36 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 36 (factor -> MINUS factor .)
    THEN            reduce using rule 36 (factor -> MINUS factor .)
    LOOP            reduce using rule 36 (factor -> MINUS factor .)
    OF              reduce using rule 36 (factor -> MINUS factor .)
    ELSE            reduce using rule 36 (factor -> MINUS factor .)
    POOL            reduce using rule 36 (factor -> MINUS factor .)
    RBRACE          reduce using rule 36 (factor -> MINUS factor .)
    FI              reduce using rule 36 (factor -> MINUS factor .)
    TIMES           reduce using rule 35 (term -> factor .)
    DIVIDE          reduce using rule 35 (term -> factor .)
    PLUS            reduce using rule 35 (term -> factor .)
    MINUS           reduce using rule 35 (term -> factor .)
    LTHAN           reduce using rule 35 (term -> factor .)
    LETHAN          reduce using rule 35 (term -> factor .)
    EQUALS          reduce using rule 35 (term -> factor .)
    DISP            reduce using rule 35 (term -> factor .)
    DOT             reduce using rule 35 (term -> factor .)

  ! TIMES           [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! DIVIDE          [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! PLUS            [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! MINUS           [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! LTHAN           [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! LETHAN          [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! EQUALS          [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! DISP            [ reduce using rule 36 (factor -> MINUS factor .) ]
  ! DOT             [ reduce using rule 36 (factor -> MINUS factor .) ]


state 83

    (59) e_factor -> MINUS e_factor .
    (58) e_term -> e_factor .

  ! reduce/reduce conflict for TIMES resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DISP resolved using rule 58 (e_term -> e_factor .)
  ! reduce/reduce conflict for DOT resolved using rule 58 (e_term -> e_factor .)
    SEMICOLON       reduce using rule 59 (e_factor -> MINUS e_factor .)
    COMMA           reduce using rule 59 (e_factor -> MINUS e_factor .)
    IN              reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACKET        reduce using rule 59 (e_factor -> MINUS e_factor .)
    PLUS            reduce using rule 59 (e_factor -> MINUS e_factor .)
    MINUS           reduce using rule 59 (e_factor -> MINUS e_factor .)
    THEN            reduce using rule 59 (e_factor -> MINUS e_factor .)
    LOOP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    OF              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ELSE            reduce using rule 59 (e_factor -> MINUS e_factor .)
    POOL            reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACE          reduce using rule 59 (e_factor -> MINUS e_factor .)
    FI              reduce using rule 59 (e_factor -> MINUS e_factor .)
    TIMES           reduce using rule 58 (e_term -> e_factor .)
    DIVIDE          reduce using rule 58 (e_term -> e_factor .)
    LTHAN           reduce using rule 58 (e_term -> e_factor .)
    LETHAN          reduce using rule 58 (e_term -> e_factor .)
    EQUALS          reduce using rule 58 (e_term -> e_factor .)
    DISP            reduce using rule 58 (e_term -> e_factor .)
    DOT             reduce using rule 58 (e_term -> e_factor .)

  ! TIMES           [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DIVIDE          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! LTHAN           [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! LETHAN          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! EQUALS          [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DISP            [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]
  ! DOT             [ reduce using rule 59 (e_factor -> MINUS e_factor .) ]


state 84

    (56) e_term -> e_term TIMES . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 115
    LET             shift and go to state 59

    e_factor                       shift and go to state 114
    let_expression                 shift and go to state 45

state 85

    (57) e_term -> e_term DIVIDE . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 115
    LET             shift and go to state 59

    e_factor                       shift and go to state 116
    let_expression                 shift and go to state 45

state 86

    (38) atom -> LBRACKET expression . RBRACKET
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    RBRACKET        shift and go to state 117
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 87

    (39) atom -> ISVOID expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 39 (atom -> ISVOID expression .)
    TIMES           reduce using rule 39 (atom -> ISVOID expression .)
    DIVIDE          reduce using rule 39 (atom -> ISVOID expression .)
    PLUS            reduce using rule 39 (atom -> ISVOID expression .)
    MINUS           reduce using rule 39 (atom -> ISVOID expression .)
    LTHAN           reduce using rule 39 (atom -> ISVOID expression .)
    LETHAN          reduce using rule 39 (atom -> ISVOID expression .)
    EQUALS          reduce using rule 39 (atom -> ISVOID expression .)
    DOT             reduce using rule 39 (atom -> ISVOID expression .)
    SEMICOLON       reduce using rule 39 (atom -> ISVOID expression .)
    COMMA           reduce using rule 39 (atom -> ISVOID expression .)
    IN              reduce using rule 39 (atom -> ISVOID expression .)
    RBRACKET        reduce using rule 39 (atom -> ISVOID expression .)
    THEN            reduce using rule 39 (atom -> ISVOID expression .)
    LOOP            reduce using rule 39 (atom -> ISVOID expression .)
    OF              reduce using rule 39 (atom -> ISVOID expression .)
    ELSE            reduce using rule 39 (atom -> ISVOID expression .)
    POOL            reduce using rule 39 (atom -> ISVOID expression .)
    RBRACE          reduce using rule 39 (atom -> ISVOID expression .)
    FI              reduce using rule 39 (atom -> ISVOID expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 39 (atom -> ISVOID expression .) ]
  ! DOT             [ reduce using rule 78 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 88

    (45) atom -> BCOMPLEMENT expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 45 (atom -> BCOMPLEMENT expression .)
    TIMES           reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    DIVIDE          reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    PLUS            reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    MINUS           reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    LTHAN           reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    LETHAN          reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    EQUALS          reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    DOT             reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    SEMICOLON       reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    COMMA           reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    IN              reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    RBRACKET        reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    THEN            reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    LOOP            reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    OF              reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    ELSE            reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    POOL            reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    RBRACE          reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    FI              reduce using rule 45 (atom -> BCOMPLEMENT expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 45 (atom -> BCOMPLEMENT expression .) ]
  ! DOT             [ reduce using rule 78 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 89

    (52) atom -> NEW TYPE .

    TIMES           reduce using rule 52 (atom -> NEW TYPE .)
    DIVIDE          reduce using rule 52 (atom -> NEW TYPE .)
    PLUS            reduce using rule 52 (atom -> NEW TYPE .)
    MINUS           reduce using rule 52 (atom -> NEW TYPE .)
    LTHAN           reduce using rule 52 (atom -> NEW TYPE .)
    LETHAN          reduce using rule 52 (atom -> NEW TYPE .)
    EQUALS          reduce using rule 52 (atom -> NEW TYPE .)
    DISP            reduce using rule 52 (atom -> NEW TYPE .)
    DOT             reduce using rule 52 (atom -> NEW TYPE .)
    SEMICOLON       reduce using rule 52 (atom -> NEW TYPE .)
    COMMA           reduce using rule 52 (atom -> NEW TYPE .)
    IN              reduce using rule 52 (atom -> NEW TYPE .)
    RBRACKET        reduce using rule 52 (atom -> NEW TYPE .)
    THEN            reduce using rule 52 (atom -> NEW TYPE .)
    LOOP            reduce using rule 52 (atom -> NEW TYPE .)
    OF              reduce using rule 52 (atom -> NEW TYPE .)
    ELSE            reduce using rule 52 (atom -> NEW TYPE .)
    POOL            reduce using rule 52 (atom -> NEW TYPE .)
    RBRACE          reduce using rule 52 (atom -> NEW TYPE .)
    FI              reduce using rule 52 (atom -> NEW TYPE .)


state 90

    (61) let_expression -> LET declaration_list . IN expression

    IN              shift and go to state 118


state 91

    (62) declaration_list -> attribute . COMMA declaration_list
    (63) declaration_list -> attribute .

    COMMA           shift and go to state 119
    IN              reduce using rule 63 (declaration_list -> attribute .)


state 92

    (46) block -> LBRACE expression_list . RBRACE

    RBRACE          shift and go to state 120


state 93

    (17) expression_list -> expression . SEMICOLON expression_list
    (18) expression_list -> expression . SEMICOLON
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    SEMICOLON       shift and go to state 121
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 94

    (64) conditional -> IF expression . THEN expression ELSE expression FI
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    THEN            shift and go to state 122
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 95

    (65) loop -> WHILE expression . LOOP expression POOL
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    LOOP            shift and go to state 123
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 96

    (66) case -> CASE expression . OF implications ESAC
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    OF              shift and go to state 124
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 97

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS . TYPE LBRACE expression RBRACE

    TYPE            shift and go to state 125


state 98

    (14) formals -> id_type COMMA formals .

    RBRACKET        reduce using rule 14 (formals -> id_type COMMA formals .)


state 99

    (70) dispatch -> expression especific DOT . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 127

    dispatch_call                  shift and go to state 126

state 100

    (72) especific -> DISP TYPE .

    DOT             reduce using rule 72 (especific -> DISP TYPE .)


state 101

    (29) assign -> ID ASSIGN expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

  ! reduce/reduce conflict for DOT resolved using rule 29 (assign -> ID ASSIGN expression .)
    DOT             reduce using rule 29 (assign -> ID ASSIGN expression .)
    SEMICOLON       reduce using rule 29 (assign -> ID ASSIGN expression .)
    COMMA           reduce using rule 29 (assign -> ID ASSIGN expression .)
    IN              reduce using rule 29 (assign -> ID ASSIGN expression .)
    RBRACKET        reduce using rule 29 (assign -> ID ASSIGN expression .)
    TIMES           reduce using rule 29 (assign -> ID ASSIGN expression .)
    DIVIDE          reduce using rule 29 (assign -> ID ASSIGN expression .)
    PLUS            reduce using rule 29 (assign -> ID ASSIGN expression .)
    MINUS           reduce using rule 29 (assign -> ID ASSIGN expression .)
    LTHAN           reduce using rule 29 (assign -> ID ASSIGN expression .)
    LETHAN          reduce using rule 29 (assign -> ID ASSIGN expression .)
    EQUALS          reduce using rule 29 (assign -> ID ASSIGN expression .)
    THEN            reduce using rule 29 (assign -> ID ASSIGN expression .)
    LOOP            reduce using rule 29 (assign -> ID ASSIGN expression .)
    OF              reduce using rule 29 (assign -> ID ASSIGN expression .)
    ELSE            reduce using rule 29 (assign -> ID ASSIGN expression .)
    POOL            reduce using rule 29 (assign -> ID ASSIGN expression .)
    RBRACE          reduce using rule 29 (assign -> ID ASSIGN expression .)
    FI              reduce using rule 29 (assign -> ID ASSIGN expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 29 (assign -> ID ASSIGN expression .) ]
  ! DOT             [ reduce using rule 78 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 102

    (74) dispatch_call -> ID LBRACKET params_expression . RBRACKET

    RBRACKET        shift and go to state 128


state 103

    (75) params_expression -> expression .
    (76) params_expression -> expression . COMMA params_expression
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    RBRACKET        reduce using rule 75 (params_expression -> expression .)
    COMMA           shift and go to state 129
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 104

    (77) params_expression -> empty .

    RBRACKET        reduce using rule 77 (params_expression -> empty .)


state 105

    (23) operator_non -> k_arith LTHAN k_arith .
    (23) operator_non -> k_arith . LTHAN k_arith
    (24) operator_non -> k_arith . LETHAN k_arith
    (25) operator_non -> k_arith . EQUALS k_arith
    (26) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 23 (operator_non -> k_arith LTHAN k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    DISP            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    DOT             reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    SEMICOLON       reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    COMMA           reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    IN              reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    RBRACKET        reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    TIMES           reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    DIVIDE          reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    PLUS            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    MINUS           reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    LTHAN           reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    LETHAN          reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    EQUALS          reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    THEN            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    LOOP            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    OF              reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    ELSE            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    POOL            reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    RBRACE          reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)
    FI              reduce using rule 23 (operator_non -> k_arith LTHAN k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 26 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 26 (operator_non -> k_arith .) ]


state 106

    (24) operator_non -> k_arith LETHAN k_arith .
    (23) operator_non -> k_arith . LTHAN k_arith
    (24) operator_non -> k_arith . LETHAN k_arith
    (25) operator_non -> k_arith . EQUALS k_arith
    (26) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 24 (operator_non -> k_arith LETHAN k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    DISP            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    DOT             reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    SEMICOLON       reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    COMMA           reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    IN              reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    RBRACKET        reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    TIMES           reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    DIVIDE          reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    PLUS            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    MINUS           reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    LTHAN           reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    LETHAN          reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    EQUALS          reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    THEN            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    LOOP            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    OF              reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    ELSE            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    POOL            reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    RBRACE          reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)
    FI              reduce using rule 24 (operator_non -> k_arith LETHAN k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 26 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 26 (operator_non -> k_arith .) ]


state 107

    (25) operator_non -> k_arith EQUALS k_arith .
    (23) operator_non -> k_arith . LTHAN k_arith
    (24) operator_non -> k_arith . LETHAN k_arith
    (25) operator_non -> k_arith . EQUALS k_arith
    (26) operator_non -> k_arith .

  ! reduce/reduce conflict for DISP resolved using rule 25 (operator_non -> k_arith EQUALS k_arith .)
  ! reduce/reduce conflict for DOT resolved using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    DISP            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    DOT             reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    SEMICOLON       reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    COMMA           reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    IN              reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    RBRACKET        reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    TIMES           reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    DIVIDE          reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    PLUS            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    MINUS           reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    LTHAN           reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    LETHAN          reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    EQUALS          reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    THEN            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    LOOP            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    OF              reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    ELSE            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    POOL            reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    RBRACE          reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)
    FI              reduce using rule 25 (operator_non -> k_arith EQUALS k_arith .)

  ! LTHAN           [ shift and go to state 75 ]
  ! LETHAN          [ shift and go to state 76 ]
  ! EQUALS          [ shift and go to state 77 ]
  ! DISP            [ reduce using rule 26 (operator_non -> k_arith .) ]
  ! DOT             [ reduce using rule 26 (operator_non -> k_arith .) ]


state 108

    (30) arith -> arith PLUS term .
    (33) term -> term . TIMES factor
    (34) term -> term . DIVIDE factor
    (32) arith -> term .

  ! reduce/reduce conflict for PLUS resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for LTHAN resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for DISP resolved using rule 30 (arith -> arith PLUS term .)
  ! reduce/reduce conflict for DOT resolved using rule 30 (arith -> arith PLUS term .)
    PLUS            reduce using rule 30 (arith -> arith PLUS term .)
    MINUS           reduce using rule 30 (arith -> arith PLUS term .)
    LTHAN           reduce using rule 30 (arith -> arith PLUS term .)
    LETHAN          reduce using rule 30 (arith -> arith PLUS term .)
    EQUALS          reduce using rule 30 (arith -> arith PLUS term .)
    DISP            reduce using rule 30 (arith -> arith PLUS term .)
    DOT             reduce using rule 30 (arith -> arith PLUS term .)
    SEMICOLON       reduce using rule 30 (arith -> arith PLUS term .)
    COMMA           reduce using rule 30 (arith -> arith PLUS term .)
    IN              reduce using rule 30 (arith -> arith PLUS term .)
    RBRACKET        reduce using rule 30 (arith -> arith PLUS term .)
    THEN            reduce using rule 30 (arith -> arith PLUS term .)
    LOOP            reduce using rule 30 (arith -> arith PLUS term .)
    OF              reduce using rule 30 (arith -> arith PLUS term .)
    ELSE            reduce using rule 30 (arith -> arith PLUS term .)
    POOL            reduce using rule 30 (arith -> arith PLUS term .)
    RBRACE          reduce using rule 30 (arith -> arith PLUS term .)
    FI              reduce using rule 30 (arith -> arith PLUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 30 (arith -> arith PLUS term .) ]
  ! DIVIDE          [ reduce using rule 30 (arith -> arith PLUS term .) ]
  ! PLUS            [ reduce using rule 32 (arith -> term .) ]
  ! MINUS           [ reduce using rule 32 (arith -> term .) ]
  ! LTHAN           [ reduce using rule 32 (arith -> term .) ]
  ! LETHAN          [ reduce using rule 32 (arith -> term .) ]
  ! EQUALS          [ reduce using rule 32 (arith -> term .) ]
  ! DISP            [ reduce using rule 32 (arith -> term .) ]
  ! DOT             [ reduce using rule 32 (arith -> term .) ]


state 109

    (53) e_arith -> arith PLUS e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor
    (55) e_arith -> e_term .

  ! reduce/reduce conflict for LTHAN resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for DISP resolved using rule 53 (e_arith -> arith PLUS e_term .)
  ! reduce/reduce conflict for DOT resolved using rule 53 (e_arith -> arith PLUS e_term .)
    LTHAN           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    LETHAN          reduce using rule 53 (e_arith -> arith PLUS e_term .)
    EQUALS          reduce using rule 53 (e_arith -> arith PLUS e_term .)
    DISP            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    DOT             reduce using rule 53 (e_arith -> arith PLUS e_term .)
    SEMICOLON       reduce using rule 53 (e_arith -> arith PLUS e_term .)
    COMMA           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    IN              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    RBRACKET        reduce using rule 53 (e_arith -> arith PLUS e_term .)
    PLUS            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    MINUS           reduce using rule 53 (e_arith -> arith PLUS e_term .)
    THEN            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    LOOP            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    OF              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    ELSE            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    POOL            reduce using rule 53 (e_arith -> arith PLUS e_term .)
    RBRACE          reduce using rule 53 (e_arith -> arith PLUS e_term .)
    FI              reduce using rule 53 (e_arith -> arith PLUS e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 53 (e_arith -> arith PLUS e_term .) ]
  ! DIVIDE          [ reduce using rule 53 (e_arith -> arith PLUS e_term .) ]
  ! LTHAN           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! LETHAN          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! EQUALS          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DISP            [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DOT             [ reduce using rule 55 (e_arith -> e_term .) ]


state 110

    (31) arith -> arith MINUS term .
    (33) term -> term . TIMES factor
    (34) term -> term . DIVIDE factor
    (32) arith -> term .

  ! reduce/reduce conflict for PLUS resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for LTHAN resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for DISP resolved using rule 31 (arith -> arith MINUS term .)
  ! reduce/reduce conflict for DOT resolved using rule 31 (arith -> arith MINUS term .)
    PLUS            reduce using rule 31 (arith -> arith MINUS term .)
    MINUS           reduce using rule 31 (arith -> arith MINUS term .)
    LTHAN           reduce using rule 31 (arith -> arith MINUS term .)
    LETHAN          reduce using rule 31 (arith -> arith MINUS term .)
    EQUALS          reduce using rule 31 (arith -> arith MINUS term .)
    DISP            reduce using rule 31 (arith -> arith MINUS term .)
    DOT             reduce using rule 31 (arith -> arith MINUS term .)
    SEMICOLON       reduce using rule 31 (arith -> arith MINUS term .)
    COMMA           reduce using rule 31 (arith -> arith MINUS term .)
    IN              reduce using rule 31 (arith -> arith MINUS term .)
    RBRACKET        reduce using rule 31 (arith -> arith MINUS term .)
    THEN            reduce using rule 31 (arith -> arith MINUS term .)
    LOOP            reduce using rule 31 (arith -> arith MINUS term .)
    OF              reduce using rule 31 (arith -> arith MINUS term .)
    ELSE            reduce using rule 31 (arith -> arith MINUS term .)
    POOL            reduce using rule 31 (arith -> arith MINUS term .)
    RBRACE          reduce using rule 31 (arith -> arith MINUS term .)
    FI              reduce using rule 31 (arith -> arith MINUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81

  ! TIMES           [ reduce using rule 31 (arith -> arith MINUS term .) ]
  ! DIVIDE          [ reduce using rule 31 (arith -> arith MINUS term .) ]
  ! PLUS            [ reduce using rule 32 (arith -> term .) ]
  ! MINUS           [ reduce using rule 32 (arith -> term .) ]
  ! LTHAN           [ reduce using rule 32 (arith -> term .) ]
  ! LETHAN          [ reduce using rule 32 (arith -> term .) ]
  ! EQUALS          [ reduce using rule 32 (arith -> term .) ]
  ! DISP            [ reduce using rule 32 (arith -> term .) ]
  ! DOT             [ reduce using rule 32 (arith -> term .) ]


state 111

    (54) e_arith -> arith MINUS e_term .
    (56) e_term -> e_term . TIMES e_factor
    (57) e_term -> e_term . DIVIDE e_factor
    (55) e_arith -> e_term .

  ! reduce/reduce conflict for LTHAN resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for LETHAN resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for DISP resolved using rule 54 (e_arith -> arith MINUS e_term .)
  ! reduce/reduce conflict for DOT resolved using rule 54 (e_arith -> arith MINUS e_term .)
    LTHAN           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    LETHAN          reduce using rule 54 (e_arith -> arith MINUS e_term .)
    EQUALS          reduce using rule 54 (e_arith -> arith MINUS e_term .)
    DISP            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    DOT             reduce using rule 54 (e_arith -> arith MINUS e_term .)
    SEMICOLON       reduce using rule 54 (e_arith -> arith MINUS e_term .)
    COMMA           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    IN              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    RBRACKET        reduce using rule 54 (e_arith -> arith MINUS e_term .)
    PLUS            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    MINUS           reduce using rule 54 (e_arith -> arith MINUS e_term .)
    THEN            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    LOOP            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    OF              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    ELSE            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    POOL            reduce using rule 54 (e_arith -> arith MINUS e_term .)
    RBRACE          reduce using rule 54 (e_arith -> arith MINUS e_term .)
    FI              reduce using rule 54 (e_arith -> arith MINUS e_term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85

  ! TIMES           [ reduce using rule 54 (e_arith -> arith MINUS e_term .) ]
  ! DIVIDE          [ reduce using rule 54 (e_arith -> arith MINUS e_term .) ]
  ! LTHAN           [ reduce using rule 55 (e_arith -> e_term .) ]
  ! LETHAN          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! EQUALS          [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DISP            [ reduce using rule 55 (e_arith -> e_term .) ]
  ! DOT             [ reduce using rule 55 (e_arith -> e_term .) ]


state 112

    (33) term -> term TIMES factor .
    (35) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DISP resolved using rule 33 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DOT resolved using rule 33 (term -> term TIMES factor .)
    TIMES           reduce using rule 33 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 33 (term -> term TIMES factor .)
    PLUS            reduce using rule 33 (term -> term TIMES factor .)
    MINUS           reduce using rule 33 (term -> term TIMES factor .)
    LTHAN           reduce using rule 33 (term -> term TIMES factor .)
    LETHAN          reduce using rule 33 (term -> term TIMES factor .)
    EQUALS          reduce using rule 33 (term -> term TIMES factor .)
    DISP            reduce using rule 33 (term -> term TIMES factor .)
    DOT             reduce using rule 33 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 33 (term -> term TIMES factor .)
    COMMA           reduce using rule 33 (term -> term TIMES factor .)
    IN              reduce using rule 33 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 33 (term -> term TIMES factor .)
    THEN            reduce using rule 33 (term -> term TIMES factor .)
    LOOP            reduce using rule 33 (term -> term TIMES factor .)
    OF              reduce using rule 33 (term -> term TIMES factor .)
    ELSE            reduce using rule 33 (term -> term TIMES factor .)
    POOL            reduce using rule 33 (term -> term TIMES factor .)
    RBRACE          reduce using rule 33 (term -> term TIMES factor .)
    FI              reduce using rule 33 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 35 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 35 (term -> factor .) ]
  ! PLUS            [ reduce using rule 35 (term -> factor .) ]
  ! MINUS           [ reduce using rule 35 (term -> factor .) ]
  ! LTHAN           [ reduce using rule 35 (term -> factor .) ]
  ! LETHAN          [ reduce using rule 35 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 35 (term -> factor .) ]
  ! DISP            [ reduce using rule 35 (term -> factor .) ]
  ! DOT             [ reduce using rule 35 (term -> factor .) ]


state 113

    (34) term -> term DIVIDE factor .
    (35) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LETHAN resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DISP resolved using rule 34 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DOT resolved using rule 34 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 34 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 34 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 34 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 34 (term -> term DIVIDE factor .)
    LTHAN           reduce using rule 34 (term -> term DIVIDE factor .)
    LETHAN          reduce using rule 34 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 34 (term -> term DIVIDE factor .)
    DISP            reduce using rule 34 (term -> term DIVIDE factor .)
    DOT             reduce using rule 34 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 34 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 34 (term -> term DIVIDE factor .)
    IN              reduce using rule 34 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 34 (term -> term DIVIDE factor .)
    THEN            reduce using rule 34 (term -> term DIVIDE factor .)
    LOOP            reduce using rule 34 (term -> term DIVIDE factor .)
    OF              reduce using rule 34 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 34 (term -> term DIVIDE factor .)
    POOL            reduce using rule 34 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 34 (term -> term DIVIDE factor .)
    FI              reduce using rule 34 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 35 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 35 (term -> factor .) ]
  ! PLUS            [ reduce using rule 35 (term -> factor .) ]
  ! MINUS           [ reduce using rule 35 (term -> factor .) ]
  ! LTHAN           [ reduce using rule 35 (term -> factor .) ]
  ! LETHAN          [ reduce using rule 35 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 35 (term -> factor .) ]
  ! DISP            [ reduce using rule 35 (term -> factor .) ]
  ! DOT             [ reduce using rule 35 (term -> factor .) ]


state 114

    (56) e_term -> e_term TIMES e_factor .

    TIMES           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DIVIDE          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LTHAN           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LETHAN          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    EQUALS          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DISP            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    DOT             reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    SEMICOLON       reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    COMMA           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    IN              reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    RBRACKET        reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    PLUS            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    MINUS           reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    THEN            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    LOOP            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    OF              reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    ELSE            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    POOL            reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    RBRACE          reduce using rule 56 (e_term -> e_term TIMES e_factor .)
    FI              reduce using rule 56 (e_term -> e_term TIMES e_factor .)


state 115

    (59) e_factor -> MINUS . e_factor
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (61) let_expression -> . LET declaration_list IN expression

    MINUS           shift and go to state 115
    LET             shift and go to state 59

    e_factor                       shift and go to state 130
    let_expression                 shift and go to state 45

state 116

    (57) e_term -> e_term DIVIDE e_factor .

    TIMES           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DIVIDE          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LTHAN           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LETHAN          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    EQUALS          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DISP            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    DOT             reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    SEMICOLON       reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    COMMA           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    IN              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    RBRACKET        reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    PLUS            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    MINUS           reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    THEN            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    LOOP            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    OF              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    ELSE            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    POOL            reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    RBRACE          reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)
    FI              reduce using rule 57 (e_term -> e_term DIVIDE e_factor .)


state 117

    (38) atom -> LBRACKET expression RBRACKET .

    TIMES           reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    LTHAN           reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    LETHAN          reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    EQUALS          reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    DISP            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    DOT             reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    IN              reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    THEN            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    LOOP            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    OF              reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    POOL            reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)
    FI              reduce using rule 38 (atom -> LBRACKET expression RBRACKET .)


state 118

    (61) let_expression -> LET declaration_list IN . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 131
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 119

    (62) declaration_list -> attribute COMMA . declaration_list
    (62) declaration_list -> . attribute COMMA declaration_list
    (63) declaration_list -> . attribute
    (10) attribute -> . id_type
    (11) attribute -> . id_type ASSIGN expression
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    attribute                      shift and go to state 91
    declaration_list               shift and go to state 132
    id_type                        shift and go to state 18

state 120

    (46) block -> LBRACE expression_list RBRACE .

    TIMES           reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    LTHAN           reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    LETHAN          reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    EQUALS          reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    DISP            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    DOT             reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    IN              reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    THEN            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    LOOP            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    OF              reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    ELSE            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    POOL            reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 46 (block -> LBRACE expression_list RBRACE .)
    FI              reduce using rule 46 (block -> LBRACE expression_list RBRACE .)


state 121

    (17) expression_list -> expression SEMICOLON . expression_list
    (18) expression_list -> expression SEMICOLON .
    (17) expression_list -> . expression SEMICOLON expression_list
    (18) expression_list -> . expression SEMICOLON
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACE          reduce using rule 18 (expression_list -> expression SEMICOLON .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 93
    expression_list                shift and go to state 133
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 122

    (64) conditional -> IF expression THEN . expression ELSE expression FI
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 134
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 123

    (65) loop -> WHILE expression LOOP . expression POOL
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 135
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 124

    (66) case -> CASE expression OF . implications ESAC
    (67) implications -> . implication SEMICOLON implications
    (68) implications -> . implication SEMICOLON
    (69) implication -> . id_type IMPLY expression
    (12) id_type -> . ID TDOTS TYPE

    ID              shift and go to state 25

    implications                   shift and go to state 136
    implication                    shift and go to state 137
    id_type                        shift and go to state 138

state 125

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE . LBRACE expression RBRACE

    LBRACE          shift and go to state 139


state 126

    (70) dispatch -> expression especific DOT dispatch_call .

    TIMES           reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    DIVIDE          reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    PLUS            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    MINUS           reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    LTHAN           reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    LETHAN          reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    EQUALS          reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    DISP            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    DOT             reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    SEMICOLON       reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    COMMA           reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    IN              reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    RBRACKET        reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    THEN            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    LOOP            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    OF              reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    ELSE            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    POOL            reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    RBRACE          reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)
    FI              reduce using rule 70 (dispatch -> expression especific DOT dispatch_call .)


state 127

    (74) dispatch_call -> ID . LBRACKET params_expression RBRACKET

    LBRACKET        shift and go to state 71


state 128

    (74) dispatch_call -> ID LBRACKET params_expression RBRACKET .

    TIMES           reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DIVIDE          reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    PLUS            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    MINUS           reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LTHAN           reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LETHAN          reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    EQUALS          reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DISP            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    DOT             reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    SEMICOLON       reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    COMMA           reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    IN              reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    RBRACKET        reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    THEN            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    LOOP            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    OF              reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    ELSE            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    POOL            reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    RBRACE          reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)
    FI              reduce using rule 74 (dispatch_call -> ID LBRACKET params_expression RBRACKET .)


state 129

    (76) params_expression -> expression COMMA . params_expression
    (75) params_expression -> . expression
    (76) params_expression -> . expression COMMA params_expression
    (77) params_expression -> . empty
    (19) expression -> . assign
    (20) expression -> . upper_non
    (78) empty -> .
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    RBRACKET        reduce using rule 78 (empty -> .)
    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 103
    params_expression              shift and go to state 140
    empty                          shift and go to state 104
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 130

    (59) e_factor -> MINUS e_factor .

    DISP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    DOT             reduce using rule 59 (e_factor -> MINUS e_factor .)
    SEMICOLON       reduce using rule 59 (e_factor -> MINUS e_factor .)
    COMMA           reduce using rule 59 (e_factor -> MINUS e_factor .)
    IN              reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACKET        reduce using rule 59 (e_factor -> MINUS e_factor .)
    TIMES           reduce using rule 59 (e_factor -> MINUS e_factor .)
    DIVIDE          reduce using rule 59 (e_factor -> MINUS e_factor .)
    PLUS            reduce using rule 59 (e_factor -> MINUS e_factor .)
    MINUS           reduce using rule 59 (e_factor -> MINUS e_factor .)
    LTHAN           reduce using rule 59 (e_factor -> MINUS e_factor .)
    LETHAN          reduce using rule 59 (e_factor -> MINUS e_factor .)
    EQUALS          reduce using rule 59 (e_factor -> MINUS e_factor .)
    THEN            reduce using rule 59 (e_factor -> MINUS e_factor .)
    LOOP            reduce using rule 59 (e_factor -> MINUS e_factor .)
    OF              reduce using rule 59 (e_factor -> MINUS e_factor .)
    ELSE            reduce using rule 59 (e_factor -> MINUS e_factor .)
    POOL            reduce using rule 59 (e_factor -> MINUS e_factor .)
    RBRACE          reduce using rule 59 (e_factor -> MINUS e_factor .)
    FI              reduce using rule 59 (e_factor -> MINUS e_factor .)


state 131

    (61) let_expression -> LET declaration_list IN expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

  ! shift/reduce conflict for DISP resolved as shift
  ! reduce/reduce conflict for DOT resolved using rule 61 (let_expression -> LET declaration_list IN expression .)
    TIMES           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DIVIDE          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LTHAN           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LETHAN          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    EQUALS          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DOT             reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    SEMICOLON       reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    COMMA           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    IN              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    RBRACKET        reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    PLUS            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    MINUS           reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    THEN            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    LOOP            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    OF              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    ELSE            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    POOL            reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    RBRACE          reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    FI              reduce using rule 61 (let_expression -> LET declaration_list IN expression .)
    DISP            shift and go to state 68

  ! DISP            [ reduce using rule 61 (let_expression -> LET declaration_list IN expression .) ]
  ! DOT             [ reduce using rule 78 (empty -> .) ]

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 132

    (62) declaration_list -> attribute COMMA declaration_list .

    IN              reduce using rule 62 (declaration_list -> attribute COMMA declaration_list .)


state 133

    (17) expression_list -> expression SEMICOLON expression_list .

    RBRACE          reduce using rule 17 (expression_list -> expression SEMICOLON expression_list .)


state 134

    (64) conditional -> IF expression THEN expression . ELSE expression FI
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    ELSE            shift and go to state 141
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 135

    (65) loop -> WHILE expression LOOP expression . POOL
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    POOL            shift and go to state 142
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 136

    (66) case -> CASE expression OF implications . ESAC

    ESAC            shift and go to state 143


state 137

    (67) implications -> implication . SEMICOLON implications
    (68) implications -> implication . SEMICOLON

    SEMICOLON       shift and go to state 144


state 138

    (69) implication -> id_type . IMPLY expression

    IMPLY           shift and go to state 145


state 139

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE . expression RBRACE
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 146
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 140

    (76) params_expression -> expression COMMA params_expression .

    RBRACKET        reduce using rule 76 (params_expression -> expression COMMA params_expression .)


state 141

    (64) conditional -> IF expression THEN expression ELSE . expression FI
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 147
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 142

    (65) loop -> WHILE expression LOOP expression POOL .

    TIMES           reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    DIVIDE          reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    PLUS            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    MINUS           reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    LTHAN           reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    LETHAN          reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    EQUALS          reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    DISP            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    DOT             reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    SEMICOLON       reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    COMMA           reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    IN              reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    RBRACKET        reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    THEN            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    LOOP            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    OF              reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    ELSE            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    POOL            reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    RBRACE          reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)
    FI              reduce using rule 65 (loop -> WHILE expression LOOP expression POOL .)


state 143

    (66) case -> CASE expression OF implications ESAC .

    TIMES           reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    DIVIDE          reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    PLUS            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    MINUS           reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    LTHAN           reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    LETHAN          reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    EQUALS          reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    DISP            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    DOT             reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    SEMICOLON       reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    COMMA           reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    IN              reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    RBRACKET        reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    THEN            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    LOOP            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    OF              reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    ELSE            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    POOL            reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    RBRACE          reduce using rule 66 (case -> CASE expression OF implications ESAC .)
    FI              reduce using rule 66 (case -> CASE expression OF implications ESAC .)


state 144

    (67) implications -> implication SEMICOLON . implications
    (68) implications -> implication SEMICOLON .
    (67) implications -> . implication SEMICOLON implications
    (68) implications -> . implication SEMICOLON
    (69) implication -> . id_type IMPLY expression
    (12) id_type -> . ID TDOTS TYPE

    ESAC            reduce using rule 68 (implications -> implication SEMICOLON .)
    ID              shift and go to state 25

    implication                    shift and go to state 137
    implications                   shift and go to state 148
    id_type                        shift and go to state 138

state 145

    (69) implication -> id_type IMPLY . expression
    (19) expression -> . assign
    (20) expression -> . upper_non
    (29) assign -> . ID ASSIGN expression
    (21) upper_non -> . NOT upper_non
    (22) upper_non -> . operator_non
    (23) operator_non -> . k_arith LTHAN k_arith
    (24) operator_non -> . k_arith LETHAN k_arith
    (25) operator_non -> . k_arith EQUALS k_arith
    (26) operator_non -> . k_arith
    (27) k_arith -> . arith
    (28) k_arith -> . e_arith
    (30) arith -> . arith PLUS term
    (31) arith -> . arith MINUS term
    (32) arith -> . term
    (53) e_arith -> . arith PLUS e_term
    (54) e_arith -> . arith MINUS e_term
    (55) e_arith -> . e_term
    (33) term -> . term TIMES factor
    (34) term -> . term DIVIDE factor
    (35) term -> . factor
    (56) e_term -> . e_term TIMES e_factor
    (57) e_term -> . e_term DIVIDE e_factor
    (58) e_term -> . e_factor
    (36) factor -> . MINUS factor
    (37) factor -> . atom
    (59) e_factor -> . MINUS e_factor
    (60) e_factor -> . let_expression
    (38) atom -> . LBRACKET expression RBRACKET
    (39) atom -> . ISVOID expression
    (40) atom -> . block
    (41) atom -> . conditional
    (42) atom -> . loop
    (43) atom -> . case
    (44) atom -> . dispatch
    (45) atom -> . BCOMPLEMENT expression
    (47) atom -> . ID
    (48) atom -> . INTEGER
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NEW TYPE
    (61) let_expression -> . LET declaration_list IN expression
    (46) block -> . LBRACE expression_list RBRACE
    (64) conditional -> . IF expression THEN expression ELSE expression FI
    (65) loop -> . WHILE expression LOOP expression POOL
    (66) case -> . CASE expression OF implications ESAC
    (70) dispatch -> . expression especific DOT dispatch_call
    (71) dispatch -> . dispatch_call
    (74) dispatch_call -> . ID LBRACKET params_expression RBRACKET

    ID              shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 40
    LBRACKET        shift and go to state 46
    ISVOID          shift and go to state 47
    BCOMPLEMENT     shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    NEW             shift and go to state 58
    LET             shift and go to state 59
    LBRACE          shift and go to state 60
    IF              shift and go to state 61
    WHILE           shift and go to state 62
    CASE            shift and go to state 63

    expression                     shift and go to state 149
    assign                         shift and go to state 31
    upper_non                      shift and go to state 32
    operator_non                   shift and go to state 35
    k_arith                        shift and go to state 36
    arith                          shift and go to state 37
    e_arith                        shift and go to state 38
    term                           shift and go to state 39
    e_term                         shift and go to state 41
    factor                         shift and go to state 42
    e_factor                       shift and go to state 43
    atom                           shift and go to state 44
    let_expression                 shift and go to state 45
    block                          shift and go to state 48
    conditional                    shift and go to state 49
    loop                           shift and go to state 50
    case                           shift and go to state 51
    dispatch                       shift and go to state 52
    dispatch_call                  shift and go to state 64

state 146

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression . RBRACE
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    RBRACE          shift and go to state 150
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 147

    (64) conditional -> IF expression THEN expression ELSE expression . FI
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    FI              shift and go to state 151
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 148

    (67) implications -> implication SEMICOLON implications .

    ESAC            reduce using rule 67 (implications -> implication SEMICOLON implications .)


state 149

    (69) implication -> id_type IMPLY expression .
    (70) dispatch -> expression . especific DOT dispatch_call
    (72) especific -> . DISP TYPE
    (73) especific -> . empty
    (78) empty -> .

    SEMICOLON       reduce using rule 69 (implication -> id_type IMPLY expression .)
    DISP            shift and go to state 68
    DOT             reduce using rule 78 (empty -> .)

    especific                      shift and go to state 67
    empty                          shift and go to state 69

state 150

    (13) method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE .

    SEMICOLON       reduce using rule 13 (method_declaration -> ID LBRACKET formals RBRACKET TDOTS TYPE LBRACE expression RBRACE .)


state 151

    (64) conditional -> IF expression THEN expression ELSE expression FI .

    TIMES           reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    DIVIDE          reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    PLUS            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    MINUS           reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    LTHAN           reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    LETHAN          reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    EQUALS          reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    DISP            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    DOT             reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    SEMICOLON       reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    COMMA           reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    IN              reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    RBRACKET        reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    THEN            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    LOOP            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    OF              reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    ELSE            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    POOL            reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    RBRACE          reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)
    FI              reduce using rule 64 (conditional -> IF expression THEN expression ELSE expression FI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LTHAN in state 36 resolved as shift
WARNING: shift/reduce conflict for LETHAN in state 36 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 39 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 39 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for DISP in state 131 resolved as shift
WARNING: reduce/reduce conflict in state 72 resolved using rule (expression -> upper_non)
WARNING: rejected rule (upper_non -> NOT upper_non) in state 72
WARNING: reduce/reduce conflict in state 82 resolved using rule (term -> factor)
WARNING: rejected rule (factor -> MINUS factor) in state 82
WARNING: reduce/reduce conflict in state 83 resolved using rule (e_term -> e_factor)
WARNING: rejected rule (e_factor -> MINUS e_factor) in state 83
WARNING: reduce/reduce conflict in state 87 resolved using rule (atom -> ISVOID expression)
WARNING: rejected rule (empty -> <empty>) in state 87
WARNING: reduce/reduce conflict in state 88 resolved using rule (atom -> BCOMPLEMENT expression)
WARNING: rejected rule (empty -> <empty>) in state 88
WARNING: reduce/reduce conflict in state 101 resolved using rule (assign -> ID ASSIGN expression)
WARNING: rejected rule (empty -> <empty>) in state 101
WARNING: reduce/reduce conflict in state 105 resolved using rule (operator_non -> k_arith LTHAN k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 105
WARNING: reduce/reduce conflict in state 106 resolved using rule (operator_non -> k_arith LETHAN k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 106
WARNING: reduce/reduce conflict in state 107 resolved using rule (operator_non -> k_arith EQUALS k_arith)
WARNING: rejected rule (operator_non -> k_arith) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (arith -> arith PLUS term)
WARNING: rejected rule (arith -> term) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (e_arith -> arith PLUS e_term)
WARNING: rejected rule (e_arith -> e_term) in state 109
WARNING: reduce/reduce conflict in state 110 resolved using rule (arith -> arith MINUS term)
WARNING: rejected rule (arith -> term) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (e_arith -> arith MINUS e_term)
WARNING: rejected rule (e_arith -> e_term) in state 111
WARNING: reduce/reduce conflict in state 112 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 112
WARNING: reduce/reduce conflict in state 113 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 113
WARNING: reduce/reduce conflict in state 131 resolved using rule (let_expression -> LET declaration_list IN expression)
WARNING: rejected rule (empty -> <empty>) in state 131
